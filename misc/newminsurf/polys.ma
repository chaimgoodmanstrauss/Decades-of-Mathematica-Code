(*^::[	Information =	"This is a Mathematica Notebook file.  It contains ASCII text, and can be	transferred by email, ftp, or other text-file transfer utility.  It should	be read or edited using a copy of Mathematica or MathReader.  If you 	received this as email, use your mail application or copy/paste to save 	everything from the line containing (*^ down to the line containing ^*)	into a plain text file.  On some systems you may have to give the file a 	name ending with ".ma" to allow Mathematica to recognize it as a Notebook.	The line below identifies what version of Mathematica created this file,	but it can be opened using any other version as well.";	FrontEndVersion = "Macintosh Mathematica Notebook Front End Version 2.2";	MacintoshStandardFontEncoding; 		fontset = title, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, e8,  24, "Times"; 	fontset = subtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, e6,  18, "Times"; 	fontset = subsubtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, italic, e6,  14, "Times"; 	fontset = section, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, grayBox, M22, bold, a20,  18, "Times"; 	fontset = subsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, blackBox, M19, bold, a15,  14, "Times"; 	fontset = subsubsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, whiteBox, M18, bold, a12,  12, "Times"; 	fontset = text, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = smalltext, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  10, "Times"; 	fontset = input, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeInput, M42, N23, bold, L-5,  12, "Courier"; 	fontset = output, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5,  12, "Courier"; 	fontset = message, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, R65535, L-5,  12, "Courier"; 	fontset = print, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5,  12, "Courier"; 	fontset = info, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, B65535, L-5,  12, "Courier"; 	fontset = postscript, PostScript, formatAsPostScript, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeGraphics, M7, l34, w282, h287,  12, "Courier"; 	fontset = name, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, italic,  10, "Geneva"; 	fontset = header, inactive, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = leftheader, inactive, L2,  12, "Times"; 	fontset = footer, inactive, noKeepOnOnePage, preserveAspect, center, M7,  12, "Times"; 	fontset = leftfooter, inactive, L2,  12, "Times"; 	fontset = help, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  10, "Times"; 	fontset = clipboard, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = completions, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special1, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special2, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special3, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special4, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special5, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	paletteColors = 128; automaticGrouping; remoteKernel = "Local"; ]:[font = text; inactive; preserveAspect]June 16, 1997, revised 11-97Here we produce evolver files for more random polyhedra that ought to produce minimal surfaces when relaxed.  These polyhedra lie in a 2j x 2k x 2l torus; and use all 8jkl vertices and 24jkl edges of the cubic lattice in this torus. To give the faces, we use the awkward but straightforward device of specifying which of the 24jkl faces of the cubic lattice are used, through 2j    (2k x 2l) matrices, 2k  (2j x 2l) matrices and 2l (2j x 2k) matrices of 0's and 1's.At least, because this system is simple, it is easy to produce the .fe file, and to check if the polyhedron is well-formed.  It is sufficient for each edge to meet exactly 2 faces, and each vertex to meet exactly 2 faces in each plane.  :[font = subsection; inactive; initialization; Cclosed; preserveAspect; startGroup]Producing the .fe files:[font = input; initialization; preserveAspect]*)Off[General::spell](*;[s]2:0,0;4,1;20,-1;2:1,13,10,Courier,1,12,0,0,0;1,13,10,Courier,0,12,65535,0,0;:[font = input; initialization; preserveAspect]*)(* hashes facelist into form {{j,k,l},d},...where {j,k,d} is "lowest" vertex of face, d is axis normal to face*)hashed[facelist_]:=(hashedlist=((ddd=#[[1]];		{ Insert[#[[{3,4}]],#[[2]],ddd],ddd})& /@ Position[facelist,1]))(*;[s]2:0,1;114,0;227,-1;2:1,13,10,Courier,1,12,0,0,0;1,13,10,Times,0,12,0,0,0;:[font = input; initialization; preserveAspect]*)(*Gives the index of the vertex at {j,k,l}*)VIndex[{j_,k_,l_}]:= Mod[l,ddimens[[3]]]+   ddimens[[3]](Mod[k,ddimens[[2]]]+ddimens[[2]](Mod[j,ddimens[[1]]]))+1(*;[s]2:0,1;44,0;161,-1;2:1,13,10,Courier,1,12,0,0,0;1,13,10,Times,0,12,0,0,0;:[font = input; initialization; preserveAspect]*)(*Given edge as {j,k,l} and direction of the edge,   returns string with the index of the endpoints, and *** or **+   if passes through wall of torus. Note assumes that   0<={j,k,l}<ddimens*)   EndsOf[{{j_,k_,l_},d_}]:= StringJoin[    			{" ",ToString[VIndex[{j,k,l}]]," ",ToString[VIndex[{j,k,l}+				RotateRight[{0,0,1},d]]],			If[{j,k,l}[[d]]+1==ddimens[[d]],				" "<>StringJoin[RotateRight[{" *"," *"," +"},d]]<>" ",				" * * * "]} ](*;[s]2:0,1;194,0;447,-1;2:1,13,10,Courier,1,12,0,0,0;1,13,10,Times,0,12,0,0,0;:[font = input; initialization; preserveAspect]*)EIndex[{j_,k_,l_},d_]:=d + 3 VIndex[{j,k,l}] -3(*:[font = input; initialization; preserveAspect]:[font = input; initialization; preserveAspect]*)(*This returns the edges around a face with "lowest"  corner at {j,k,l} and normal to direction d*)EdgesOf[{{j_,k_,l_},d_}]:= StringJoin[    			{" ",ToString[EIndex[{j,k,l}, Mod[d,3]+1]],   			 " ",ToString[EIndex[{j,k,l}+   			 		RotateRight[{0,0,1},Mod[d,3]+1],Mod[d+1,3]+1]],   			 " -",ToString[EIndex[{j,k,l}+   			 		RotateRight[{0,0,1},Mod[d+1,3]+1],Mod[d,3]+1]],   			 " -",ToString[EIndex[{j,k,l}, Mod[d+1,3]+1]]}](*;[s]3:0,0;1,1;102,0;434,-1;2:2,13,10,Courier,1,12,0,0,0;1,13,10,Times,0,12,0,0,0;:[font = input; initialization; preserveAspect; endGroup]*)WritePoly[facelist_,filename_]:=   (hashedlist=hashed[facelist];   dimens=ToString /@ (Length /@ facelist);   ddimens= Length /@facelist ;   file="s."<>ToString[filename]<>".fe";OpenWrite[file];WriteString[file,"parameter p1x="<>dimens[[1]]<>"\n"<>"parameter p1y=0 \n"<>"parameter p1z=0 \n"<>"parameter p2x=0 \n"<>"parameter p2y="<>dimens[[2]]<>"\n" <>"parameter p2z=0 \n"<>"parameter p3x=0 \n"<>"parameter p3y=0 \n"<>"parameter p3z="<>dimens[[3]]<>"\n"<>"#include \"quasi.eh\" ",(* Old Way:		"// minimal surface in torus \n",		"TORUS\n periods \n",		ToString[dimens[[1]]]," 0 0\n","0 ",ToString[dimens[[2]]], " 0\n",		"0 0 ",ToString[dimens[[3]]],"\n \n",		"quantity h2 energy modulus 100 ", 		"global_method sq_mean_curvature \n\n",*)					(*vertices*)	"vertices\n",	verts=Flatten[			Table[{i,j,k},				{i,0,ddimens[[1]]-1},{j,0,ddimens[[2]]-1},{k,0,ddimens[[3]]-1} ],2];		iii=0;StringJoin[ (iii++;ToString[iii]<>" "<> ToString[#[[1]] ]<>" "<>			 ToString[#[[2]]]<>" "<>ToString[#[[3]]]<>" \n")&/@verts],								(*edges*)	" \n edges \n",	edges=Flatten[Table[{verts[[j]],k},{j,1,Length[verts]},{k,1,3}],1];	iii=0;StringJoin[ (iii++;ToString[iii]<>EndsOf[#]<>" \n")&/@edges],		(*faces*)	 "\n faces \n", StringJoin[	iii=0;(iii++;ToString[iii]<>(EdgesOf[#])<>" \n")& /@ hashedlist],	"#include \"quasi.et\""];  Close[file])(*;[s]25:0,0;74,1;242,0;253,1;349,0;360,1;457,0;468,1;507,2;769,1;777,2;789,1;812,0;939,1;1035,0;1036,1;1057,2;1066,1;1154,0;1179,1;1210,0;1211,1;1226,2;1235,1;1373,0;1378,-1;3:9,13,10,Courier,1,12,0,0,0;12,13,10,Courier,1,12,0,0,65535;4,13,10,Times,0,12,0,0,0;:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Making polyhedra within mathematica::[font = input; preserveAspect] VertsOfFace[{{j_,k_,l_},d_}]:=(	#+{j,k,l})& /@	(RotateRight[#,d]&/@ {{0,0,0},{0,1,0},{1,1,0},{1,0,0}}):[font = input; preserveAspect]Poly[facelist_]:=(Polygon /@(VertsOfFace /@ hashed[facelist])):[font = input; preserveAspect]CheckIt[facelist_,options___]:=	Show[Graphics3D[Poly[facelist],Boxed->False,options ]]:[font = input; preserveAspect]CheckIt[poly1,Lighting->True,Axes->False]:[font = input; preserveAspect; startGroup]Show[Graphics3D[#]]& @@ Join[{Poly[poly1]},  {Axes->True},{Boxed->False}]:[font = output; output; inactive; preserveAspect; endGroup]Graphics3D["<<>>"];[o]-Graphics3D-:[font = input; preserveAspect; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Generating the planar diagrams::[font = input; initialization; preserveAspect]*)upstyle={AbsoluteThickness[3],GrayLevel[0]};downstyle={AbsoluteThickness[3],GrayLevel[.5]};facestyle={GrayLevel[.8]};offset=.06;(*;[s]2:0,1;131,0;133,-1;2:1,13,10,Courier,1,12,0,0,0;1,13,10,Courier,1,12,0,0,65535;:[font = input; initialization; preserveAspect; endGroup]*)Diagram[facelist_(*assume layer 1, normal 1*),name_]:=Show[Graphics[(ddimens= Length /@ facelist;							    Join[	    	facestyle, 	    	Select[Join @@  	    		Table[	    			If[facelist[[1]][[1]][[j]][[k]]==1,	    				Polygon[{{-j,-k},{-j+1,-k},{-j+1,-k+1},{-j,-k+1}}]],	    				{j,1,ddimens[[2]]},{k,1,ddimens[[3]]}],	    		#=!=Null&],	    	Select[Flatten[	    		Table[If[j==ddimens[[2]]+1,jj=1,jj=j];	    			jjj=facelist[[2]][[jj]][[1]][[k]]+ 	    			    2*facelist[[2]][[jj]][[2]][[k]];	    			If[jjj==1,Append[upstyle,Line[{{-j+1,-k},{-j+1,-k+1}}]],	    			If[jjj==2,Append[downstyle,Line[{{-j+1,-k},{-j+1,-k+1}}]],	    			If[jjj==3,Join[	    				upstyle,{Line[{{-j+1-offset,-k},{-j+1-offset,-k+1}}]},	    				downstyle,{Line[{{-j+1+offset,-k},{-j+1+offset,-k+1}}]}]]]],	    			{j,1,ddimens[[2]]+1},{k,1,ddimens[[3]]}]],			    		#=!=Null&],	    	Select[Flatten[	    		Table[If[k==ddimens[[3]]+1,kk=1,kk=k];	    			jjj=facelist[[3]][[kk]][[1]][[j]]+ 	    			    2*facelist[[3]][[kk]][[2]][[j]];	    			If[jjj==1,Append[upstyle,Line[{{-j,-k+1},{-j+1,-k+1}}]],	    			If[jjj==2,Append[downstyle,Line[{{-j,-k+1},{-j+1,-k+1}}]],	    			If[jjj==3,Join[	    				upstyle,{Line[{{-j,-k+1-offset},{-j+1,-k+1-offset}}]},	    				downstyle,{Line[{{-j,-k+1+offset},{-j+1,-k+1+offset}}]}]]]],	    			{j,1,ddimens[[2]]},{k,1,ddimens[[3]]+1}]],			    		#=!=Null&],	    	{GrayLevel[0], Text[FontForm[name,{"Times",12}], {1,-1}]}	    	    		    	]	    		    		    	)	    		    ,AspectRatio->Automatic,PlotRange->All]](*:[font = subsection; inactive; preserveAspect; startGroup]Dot Diagrams:[font = text; inactive; preserveAspect]HEre we would like to automatically search for 2Nx2Mx2 polyhedraThese can be encoded as a graph on the NxM torus; we can represent this graph as two lists oflists of 0's and 1's.For example:{ { {1,1,0},{0,0,0}},{{1,1},{0,0},{0,1}}}:[font = subsubsection; inactive; preserveAspect; startGroup]For checking work::[font = input; initialization; preserveAspect; endGroup]*)DotDiagram[glist_]:=	Graphics[	(ddimens=Length /@ glist;	graphlist=(RotateRight /@ #)& /@ glist; 	Join[		{AbsoluteThickness[.5],GrayLevel[.7],Line[{{-.5,-.5},{-.5-ddimens[[1]],-.5},			{-.5-ddimens[[1]],-.5-ddimens[[2]]},{-.5,-.5-ddimens[[2]]},{-.5,-.5}}],				GrayLevel[0]},	  	Flatten[Table[	  		Disk[{-j,-k},.12],	  			{j,1,ddimens[[1]]},{k,1,ddimens[[2]]}]	  		],	  	{Thickness[.02]},	  	Select[Flatten[Table[	  		If[k==ddimens[[2]]+1, kk=1,kk=k];	  		If[graphlist[[1]][[j]][[kk]]==1,	  			Line[{{-j,-k+1},{-j,-k}}]],	  		{j,1,ddimens[[1]]},{k,1,ddimens[[2]]+1}]],	  		#=!=Null&],	  	Select[Flatten[Table[	  		If[j==ddimens[[1]]+1, jj=1,jj=j];	  		If[graphlist[[2]][[k]][[jj]]==1,	  			Line[{{-j+1,-k},{-j,-k}}]],	  		{j,1,ddimens[[1]]+1},{k,1,ddimens[[2]]}]],	  		#=!=Null&]	  		  	] 	  ),AspectRatio->Automatic,	  	PlotRange->{{-.5-ddimens[[1]],-.5},{-.5-ddimens[[2]],-.5}}	  ]	(*:[font = subsubsection; inactive; initialization; preserveAspect; startGroup]Group Operations on the diagrams:[font = input; initialization; preserveAspect]*)DotShiftDown[glist_,n_]:= {RotateRight[#,n]& /@ glist[[1]],RotateRight[glist[[2]],n]}DotShiftDown[glist_]:=DotShiftDown[glist,1]	(*:[font = input; initialization; preserveAspect]*)DotShiftLeft[glist_,n_]:=	{RotateRight[glist[[1]],n],RotateRight[#,n]& /@ glist[[2]]}DotShiftLeft[glist_]:=DotShiftLeft[glist,1](*:[font = input; initialization; preserveAspect]*)DotShift[glist_,m_,n_]:=DotShiftLeft[DotShiftDown[glist,m],n](*:[font = input; initialization; preserveAspect]*)DotFlipLeft[glist_]:={Reverse[glist[[1]]],RotateLeft /@(Reverse /@ glist[[2]])}(*:[font = input; initialization; preserveAspect]*)DotFlipUp[glist_]:={RotateLeft /@ (Reverse /@ glist[[1]]),	Reverse[glist[[2]]]}(*:[font = input; initialization; preserveAspect; endGroup]*)DotFlipDiag[glist_]:=Reverse[glist](*:[font = subsubsection; inactive; initialization; preserveAspect; startGroup]Producing Equivalent diagrams:[font = text; inactive; initialization; preserveAspect]These diagrams should all produce the same polyhedra:[font = input; initialization; preserveAspect]*)DualDot[glist_]:= glist /. {0->1,1->0}(*:[font = input; initialization; preserveAspect]*)CompDualDot[glist_]:=Reverse[	(RotateLeft /@ #)& /@ (Transpose /@ glist)](*:[font = input; initialization; preserveAspect; endGroup]*)CompDot[glist_]:=CompDualDot[DualDot[glist]](*:[font = subsubsection; inactive; preserveAspect; startGroup]GeneratingLists:[font = input; initialization; preserveAspect]*)Permute[expr_,n_]:=	If[n>=Length[expr],{expr},	If[n==0,{{}},	Join @@ 	Table[ 	(Prepend[#,expr[[k]]] &) /@			Permute[Drop[expr,k],n-1],		{k,1,Length[expr]-n+1}]	]](*:[font = input; initialization; preserveAspect; startGroup]*)Positions[m_,n_]:= Flatten[ 	Table[If[i==1, {i,j,k},{i,k,j}],{i,1,2},{j,1,m},{k,1,n}],2](*:[font = message; inactive; preserveAspect; endGroup]General::spell1: Possible spelling error: new symbol name "Positions"     is similar to existing symbol "Position".:[font = input; initialization; preserveAspect]*)AllDots[m_,n_,p_]:=Module[{ttt=Permute[Positions[m,n],p]},Table[{ Table[If[MemberQ[ttt[[l]],{1,j,k}],1,0],{j,1,m},{k,1,n}],	Table[If[MemberQ[ttt[[l]],{2,k,j}],1,0],{k,1,n},{j,1,m}]},	{l,1,Length[ttt]}]](*:[font = input; initialization; preserveAspect]*)Equiv[glist_]:= (*assumes ddimens already known*)	(			Union[Flatten[ (	Table[DotShift[#,j,i],{i,1,ddimens[[1]]},{j,1,ddimens[[2]]}]& 		/@ 		(If[ddimens[[1]]==ddimens[[2]], 				Union[Flatten[   			{#,DualDot[#],CompDualDot[#],CompDot[#]}&  /@ 		Union[Flatten[			({#,DotFlipDiag[#]}& /@ 		Union[Flatten[			({#,DotFlipLeft[#]}& /@				({#,DotFlipUp[#]}& @@ {glist})),1]])			 ,1]],1]],				Union[Flatten[			{#,DualDot[#],CompDualDot[#],CompDot[#]}&  /@ 			Union[Flatten[			({#,DotFlipLeft[#]}& /@				({#,DotFlipUp[#]}& @@ {glist})),1]],1]]		]))			,2]])						(*:[font = input; initialization; preserveAspect]*)NoSmallerPeriod[glist_]:=Module[{temp,i,j},		!MemberQ[ 		Join[ 	Table[DotShiftDown[glist,i],{i,1,ddimens[[2]]-1}],	Table[DotShiftLeft[glist,i],{i,1,ddimens[[1]]-1}]	],glist]]			(*:[font = input; initialization; preserveAspect]*)ReduceDots[dotlist_]:=Module[{iter,reducedlist,templist(*,maxlist*)},	ddimens= Length /@ (dotlist[[1]]);	 iter=1;	 reducedlist={};	 maxlist={};	 While[iter <= Length[dotlist],	 	If[Not[MemberQ[maxlist,dotlist[[iter]] ]],	 	If[NoSmallerPeriod[dotlist[[iter]]],	 	reducedlist= Append[reducedlist,dotlist[[iter]] ];	 	maxlist=Join[maxlist,Equiv[dotlist[[iter]]	]]]];iter++];	 reducedlist]	(*:[font = input; initialization; preserveAspect; endGroup]*)FullDots[m_,n_]:=Join @@ Table[AllDots[m,n,k],{k,0,m*n}](*:[font = subsubsection; inactive; preserveAspect; startGroup]Producing Facelists of 2M x 2N x 2 polyhedra from dot diagrams:[font = input; initialization; preserveAspect]*)floorlist[m_,n_]:=floorlist[m,n] =	Table[If[EvenQ[j+k],0,1],{j,1,m},{k,1,n}](*:[font = input; initialization; preserveAspect; endGroup]*)Polyfacelist[dotlist_]:=(ddimens=  (Length /@ dotlist);		{	{floorlist @@ (2 ddimens), floorlist @@ (2 ddimens) },		Table[			Mod[w+1+z+ dotlist[[ 				Mod[z,2]+1, 				If[EvenQ[z], Ceiling[y/2],(z+1)/2],				If[EvenQ[z], z/2, Mod[Floor[y/2]-1,ddimens[[1]]]+1] ]], 2 ],			{y,1,2 ddimens[[1]]},{w,1,2},{z,1,2 ddimens[[2]]}],		Table[			Mod[w+1+z+dotlist[[				Mod[z-1,2]+1,				If[EvenQ[z],  Ceiling[y/2], (z+1)/2],				If[EvenQ[z], z/2, Mod[Floor[y/2]-1,ddimens[[2]]]+1] ]], 2  ],			{y,1,2 ddimens[[2]]},{w,1,2},{z,1,2 ddimens[[1]]}]						})(*:[font = subsubsection; inactive; preserveAspect; startGroup]Automating the process::[font = input; initialization; preserveAspect; endGroup; endGroup]*)ProduceAll[m_,n_]:=Module[{temp,ttemp,name,glist1,iter,dd},	temp=ReduceDots[FullDots[m,n]];	glist1=DotDiagram /@ temp;	ttemp=Polyfacelist /@ temp;	iter=1;	glist2={};	While[iter<=Length[ttemp], name=ToString[ 2 m]<>ToString[2 n]<>"2."<>ToString[iter];		glist2=Append[glist2,Diagram[ttemp[[iter]],name]];		WritePoly[ttemp[[iter]], name]		;iter++];	dd=Ceiling[(Length[glist1]/4)//N];		If[dd>1, glist1=Join[glist1,Table[Graphics[{}],{k,1,4 dd - Length[glist1]}] ];	         glist2=Join[glist2,Table[Graphics[{}],{k,1,4 dd - Length[glist2]}] ];	         Show[GraphicsArray[Table[glist1[[ (k-1) 4 + j]],{k,1,dd},{j,1,4}]]];	         Show[GraphicsArray[Table[glist2[[ (k-1) 4 + j]],{k,1,dd},{j,1,4}]]],	       Show[GraphicsArray[glist1]];Show[GraphicsArray[glist2]] ]		](*:[font = subsection; inactive; preserveAspect; startGroup]Padded Towers:[font = input; preserveAspect](*ProduceTowers*)maxpad={3,3};padtower={{{0}},{{1}}};PadTowerDotList[padtower_,maxpad_]:=(dim=Length /@ padtower; dimax=dim+maxpad;Flatten[Table[	{Table[If[j<=dim[[1]] && k<=dim[[2]],padtower[[1,j,k]],0],		{j,1,jjj},{k,1,kkk}],	Table[If[j<=dim[[2]] && k<=dim[[1]],padtower[[2,j,k]],0],		{j,1,kkk},{k,1,jjj}]},			{jjj,dim[[1]]+1,dimax[[1]]},			{kkk,dim[[2]]+1,dimax[[2]]}],1])						:[font = text; inactive; preserveAspect]padtow={ {{1,0,1},{0,1,0}},{{0,1},{1,1},{0,0}}};dotlists= Prepend[PadTowerDotList[padtow, {3,2}],padtow];Show[#]& /@(DotDiagram /@ dotlists):[font = input; preserveAspect; endGroup]Padfefiles[padtower_,maxpad_,name_]:=	Module[{(*templist,*)iii},	templist=PadTowerDotList[padtower,maxpad];	templist2=(Length /@ #) & /@ templist;	templist3=Polyfacelist /@ templist;	iii=1;	While[iii<=Length[templist], WritePoly[templist3[[iii]],		"tower."<>		name<>"."<>ToString[templist2[[iii,1]]]<>"."<>		ToString[templist2[[iii,2]]]];iii++]]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Making Mirror .fe files:[font = input; preserveAspect](*Gives the index of the vertex at {j,k,l} ;     NOTE CHANGE!!*)VIndex[{j_,k_,l_}]:= Mod[l,ddimens[[3]]]+   ddimens[[3]](Mod[k,ddimens[[2]]]+ddimens[[2]](j))+1EndsOf[{{j_,k_,l_},d_}]:= StringJoin[    			{" ",ToString[VIndex[{j,k,l}]]," ",ToString[VIndex[{j,k,l}+				RotateRight[{0,0,1},d]]],			If[({j,k,l}[[d]]+1==ddimens[[d]])&&d=!=1,				" "<>StringJoin[RotateRight[{" *"," *"," +"},d]]<>" ",				" * * * "]} ]												Polyfacelist[dotlist_]:=(ddimens=  (Length /@ dotlist);		{	{floorlist @@ (2 ddimens),{} },		Table[			Mod[w+1+z+ dotlist[[ 				Mod[z,2]+1, 				If[EvenQ[z], Ceiling[y/2],(z+1)/2],				If[EvenQ[z], z/2, Mod[Floor[y/2]-1,ddimens[[1]]]+1] ]], 2 ],			{y,1,2 ddimens[[1]]},{w,1,2},{z,1,2 ddimens[[2]]}],		Table[			Mod[w+1+z+dotlist[[				Mod[z-1,2]+1,				If[EvenQ[z],  Ceiling[y/2], (z+1)/2],				If[EvenQ[z], z/2, Mod[Floor[y/2]-1,ddimens[[2]]]+1] ]], 2  ],			{y,1,2 ddimens[[2]]},{w,1,2},{z,1,2 ddimens[[1]]}]						});[s]2:0,1;64,0;961,-1;2:1,13,10,Courier,1,12,0,0,0;1,13,10,Times,0,12,0,0,0;:[font = input; preserveAspect]mWritePoly[facelist_,filename_]:=   (dimens=ToString /@ (Length /@ facelist);   ddimens= Length /@facelist ;   hashedlist=	({Inner[Mod,#[[1]],(ddimens),List],#[[2]]}& /@ hashed[facelist]);   file="m."<>ToString[filename]<>".fe";OpenWrite[file];WriteString[file,"parameter p1x="<>dimens[[1]]<>"\n"<>"parameter p1y=0 \n"<>"parameter p1z=0 \n"<>"parameter p2x=0 \n"<>"parameter p2y="<>dimens[[2]]<>"\n" <>"parameter p2z=0 \n"<>"parameter p3x=0 \n"<>"parameter p3y=0 \n"<>"parameter p3z="<>dimens[[3]]<>"\n"<>"#include \"quasim.eh\" ",			(*vertices*)	"vertices\n",	verts=Flatten[			Table[{i,j,k},				{i,0,ddimens[[1]]},{j,0,ddimens[[2]]-1},{k,0,ddimens[[3]]-1} ],2];		iii=0;StringJoin[ (iii++;	ToString[iii]<>" "<> ToString[(#[[1]]+1).5 ]<>" "<>			 ToString[#[[2]]]<>" "<>ToString[#[[3]]]<>			 If[#[[1]]==0," constraint 2 \n ", If[#[[1]]==2, " constraint 1 \n ", " \n "]]			 )&/@verts],								(*edges*)	" \n edges \n",	edges=Flatten[Table[{verts[[j]],k},{j,1,Length[verts]},{k,1,3}],1];	iii=0;StringJoin[ (iii++;		If[((#[[1,1]]==2)&&(#[[2]]==1))||					((#[[1,1]]==2)&& 						(#[[2]]==2)&& (!MemberQ[hashedlist,{#[[1]]-{1,0,0},3}]))||					((#[[1,1]]==2)&& (#[[2]]==3)&&						(!MemberQ[hashedlist,{#[[1]]-{1,0,0},2}] )) ||				((#[[1,1]]==0) &&(#[[2]]==2) && !(MemberQ[hashedlist,{#[[1]],3}])) || 				((#[[1,1]]==0) &&(#[[2]]==3) && !(MemberQ[hashedlist,{#[[1]],2}])) ,		"// ",""]<>ToString[iii]<>EndsOf[#]<>		If[(#[[1,1]]==2)&&(#[[2]]=!=1)," constraint 1 \n ", If[(#[[1,1]]==0)&&(#[[2]]=!=1),			" constraint 2 \n ",			" \n"]])&/@edges],		(*faces*)	 "\n faces \n", StringJoin[	iii=0;(iii++;ToString[iii]<>(EdgesOf[#])<>" \n")& /@	hashedlist],	"#include \"quasim.et\""];  Close[file]);[s]27:0,0;43,1;119,0;130,1;132,0;196,1;292,0;303,1;399,0;410,1;507,0;518,1;560,2;572,1;595,0;721,1;905,0;906,1;927,2;936,1;1024,0;1424,1;1571,0;1572,1;1587,2;1596,1;1736,0;1741,-1;3:11,13,10,Courier,1,12,0,0,0;13,13,10,Courier,1,12,0,0,65535;3,13,10,Times,0,12,0,0,0;:[font = input; preserveAspect; endGroup]ProduceAll[m_,n_]:=Module[{temp,ttemp,name,glist1,iter,dd},	temp=ReduceDots[FullDots[m,n]];	glist1=DotDiagram /@ temp;	ttemp=Polyfacelist /@ temp;	iter=1;	glist2={};	While[iter<=Length[ttemp], name=ToString[ 2 m]<>ToString[2 n]<>"2."<>ToString[iter];		glist2=Append[glist2,Diagram[ttemp[[iter]],name]];		mWritePoly[ttemp[[iter]], name]		;iter++];	dd=Ceiling[(Length[glist1]/4)//N];		If[dd>1, glist1=Join[glist1,Table[Graphics[{}],{k,1,4 dd - Length[glist1]}] ];	         glist2=Join[glist2,Table[Graphics[{}],{k,1,4 dd - Length[glist2]}] ];	         Show[GraphicsArray[Table[glist1[[ (k-1) 4 + j]],{k,1,dd},{j,1,4}]]];	         Show[GraphicsArray[Table[glist2[[ (k-1) 4 + j]],{k,1,dd},{j,1,4}]]],	       Show[GraphicsArray[glist1]];Show[GraphicsArray[glist2]] ]		]:[font = subsection; inactive; preserveAspect; startGroup]Making complementary graphs drift:[font = text; inactive; preserveAspect]be sure to evaluate the commands in the dot-diagram section first:[font = input; preserveAspect] :[font = input; preserveAspect]DriftDotDiagram[glist_]:=	(ddimens=Length /@ glist;	edges=Map[padlist,	{glist, DualDot[glist],CompDot[glist],CompDualDot[glist]},{3}];	vertices=Table[{j,k},{j,1,ddimens[[1]]},{k,1,ddimens[[2]]}];	vertices={vertices,vertices,vertices+.5,vertices+.5};	vertices=(Join @@ # &) /@ Table[vertices[[i,j,k]]+ epsilon		(edges[[i,1,j,k]]{0,-1}+edges[[i,1,j,k+1]]{0,1}+		 edges[[i,2,k,j]]{-1,0}+edges[[i,2,k,j+1]]{1,0}),		{i,1,4},{j,1,ddimens[[1]]},{k,1,ddimens[[2]]}];		Show[Graphics[Join[	{GrayLevel[0]},Disk[#,epsilon]&/@ vertices[[1]],	{GrayLevel[.3]},Disk[#,epsilon]&/@ vertices[[2]],	{GrayLevel[.6]},Disk[#,epsilon]&/@ vertices[[3]],	{GrayLevel[.9]},Disk[#,epsilon]&/@ vertices[[4]] ],AspectRatio->Automatic]]		):[font = input; preserveAspect; startGroup]epsilon:=.05DriftDotDiagram[{{{1,0,0},{0,1,1}},{{0,1},{1,1},{0,0}}}]:[font = postscript; PostScript; formatAsPostScript; output; inactive; preserveAspect; pictureLeft = 22; pictureWidth = 231; pictureHeight = 365]%!%%Creator: Mathematica%%AspectRatio: 1.58824 MathPictureStart%% Graphics/Courier findfont 10  scalefont  setfont% Scaling calculations-0.480392 0.560224 -0.466387 0.560224 [[ 0 0 0 0 ][ 1 1.58824 0 0 ]] MathScale% Start of Graphics1 setlinecap1 setlinejoinnewpath[ ] 0 setdash0 gpP0 0 m1 0 L1 1.58824 L0 1.58824 Lclosepathclipnewpathp.004 w.05182 .12185 m.05182 .12185 .02801 0 365.73 arcF.07983 .62605 m.07983 .62605 .02801 0 365.73 arcF.07983 1.21429 m.07983 1.21429 .02801 0 365.73 arcF.66807 .06583 m.66807 .06583 .02801 0 365.73 arcF.64006 .68207 m.64006 .68207 .02801 0 365.73 arcF.64006 1.21429 m.64006 1.21429 .02801 0 365.73 arcF.3 g.10784 .06583 m.10784 .06583 .02801 0 365.73 arcF.07983 .68207 m.07983 .68207 .02801 0 365.73 arcF.07983 1.21429 m.07983 1.21429 .02801 0 365.73 arcF.61204 .12185 m.61204 .12185 .02801 0 365.73 arcF.64006 .62605 m.64006 .62605 .02801 0 365.73 arcF.64006 1.21429 m.64006 1.21429 .02801 0 365.73 arcF.6 g.38796 .34594 m.38796 .34594 .02801 0 365.73 arcF.33193 .96218 m.33193 .96218 .02801 0 365.73 arcF.33193 1.4944 m.33193 1.4944 .02801 0 365.73 arcF.89216 .37395 m.89216 .37395 .02801 0 365.73 arcF.94818 .96218 m.94818 .96218 .02801 0 365.73 arcF.94818 1.46639 m.94818 1.46639 .02801 0 365.73 arcF.9 g.33193 .40196 m.33193 .40196 .02801 0 365.73 arcF.38796 .90616 m.38796 .90616 .02801 0 365.73 arcF.38796 1.4944 m.38796 1.4944 .02801 0 365.73 arcF.94818 .37395 m.94818 .37395 .02801 0 365.73 arcF.89216 .90616 m.89216 .90616 .02801 0 365.73 arcF.89216 1.52241 m.89216 1.52241 .02801 0 365.73 arcFP% End of GraphicsMathPictureEnd:[font = output; output; inactive; preserveAspect; endGroup; endGroup]Graphics["<<>>"];[o]-Graphics-^*)