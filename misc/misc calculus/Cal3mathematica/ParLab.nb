(**************************************************	Parametric Curves Package		Chaim Goodman-Strauss, (c) 1997	***************************************************)(* Summary: We give various functions to plot curves,	tangents, normals, etc *)		(* YOU MUST PLACE THIS FILE IN THE PACKAGES FOLDER *)			BeginPackage["`ParametricLab`"](* Curves *)BumpyCircle::usage = 	"BumpyCircle[number,shallowness] gives a parametric equation	{x(t), y(t)} of a bumpy unit circle  of mean radius 1. 	number is the number of bumps; 	the larger shallowness is, the larger the bumps. When plotting, t should run from 0 to 1."			t::usage = "Main parameter; For closed curves, always runs from 0 to 1"			Spirograph::usage =  "Spirograph[p,q,s] gives the  parametric equation for the Spirograph:   we have two wheels, a big one with p teeth, little with q teeth. The little  wheel has radius 1 and is inside big wheel. Hole for pen is distance   s from center of little wheel.  The curve produced is classically known as a hypotrochoid.  When plotting, t should run from 0 to 1."Lissajous::usage ="A lisssajous curve is of the form {Sin[ a t], Cos[b t]}For relatively prime m,n, Lissajous[m,n] returns a curve with m bumps one way and n bumps the other way.  When plotting, t should run from 0 to 1."ParPlot::usage = "ParPlot[{xt,yt},{tmin,tmax},(options)] plots the curve{xt,yt} as a function of t, as t varies from tmin to tmax. "ParPlotOptions::usage="Options for ParPlot include all standard Graphicsoptions, as well as  ParCurve, PlotPoints (resolution of curve), LineWidth, ParDots, ParTans,  ParAcc, ParNorms, ParUnitNorms." ParCurve::usage=" An option for ParPlot. ParCurve->True is the default. When ParCurve->False, theparametric curve itself is not plotted"LineWidth::usage="An option for ParPlot. This sets the absolute thickness of all lines."NumDots::usage=" An option for ParPlot. This sets the number ofdots or vectors to be placed along the curve"				ParDots::usage="An option for ParPlot. ParDots->True		plots colored dots along the curve, spaced as t varies.		 At tmin the  dots aregreen, at tmax, the dots are purple."		 		DotWidth::usage="An option for ParPlot. DotWidth sets the		absolute size of the dots if ParDots->True"						TanLength::usage="An option for ParPlot.		When ParTan->True, the length of the tangent vectors is scaled		to an appropriate size, so they don't dominate the image.		This allows this scaling to be adjusted"				PolarPlot::usage=		"PolarPlot[{r,theta},{tmin,tmax},(opts)] plots (r, theta) as		functions of t as t runs from t min to tmax. opts is optional		ParPlot options"			ParTans::usage="An option for ParPlot.		When ParTan->True, the tangent vectors are placed along the curve"					ParAcc::usage="An option for ParPlot.		When ParAcc->True, the acceleration vectors are placed along the curve"					ParNorms::usage="An option for ParPlot.		When ParNorms->True, the normal vectors  (d/dt  v/||v||) are placed along the curve. 		ParNorms->True overides ParAcc->True"							ParUnitNorms::usage="An option for ParPlot.		When ParUnitNorms->True, the unit normal vectors  (|| (d/dt  v/||v||) ||) are placed along the curve. 		ParUnitNorms->True overides ParAcc->True and  ParNorms->True"				UnitNorm::usage="An option for ParPlot. Scales unit norm"				ParPlotStyle::usage="An option for ParPlot. Allows graphics primatives to be inserted									at the beginning of the list of primatives produced by ParPlot."																		ParShow::usage="An option for ParPlot. Defaults to True, but when set to False, allows													one not to Show the graphics output. Used to combine images."		Begin["`Private`"]  (* To learn Mathematica check this out! *)(* Curves *)BumpyCircle[number_,shallowness_]:=	(Sin[number 2 Pi t]+shallowness)/(1+shallowness) *		{Sin[2 Pi t], Cos[2 Pi t]}						Lissajous[m_,n_]:= Module[{tt},tt=GCD[m,n]; 	{Sin[m/tt 2 Pi t], Cos[n/tt 2 Pi t]}] 						Spirograph[p_Integer,q_Integer,s_]:= Module[{tmax},tmax=2Pi*q/GCD[p,q]; {(p/q-1)Cos[tmax t]+s Cos[(1-p/q)tmax t],	(p/q-1)Sin[tmax t]+s Sin[(1-p/q)tmax t]	} ]													(* Plotting *)			ParPlot[curve_,{varmin_,varmax_},opt___]:=		Module[{opts,optins,cccurve,dots,tans,normals,norms,			linesize,dtsize,parstyle,noshow,grlist},	opts={opt,Axes->True};	optins=FilterOpts[ParLabOptions, ParLabDefaults,opts];	cccurve=SetDefault[opts,ParCurve,True];	dots =SetDefault[opts,ParDots,False];	tans =SetDefault[opts,ParTans,False];	norms = SetDefault[opts,ParAcc,False];	normals = SetDefault[opts,ParNorms,False];	unnorms = SetDefault[opts,ParUnitNorms,False];	linesize = SetDefault[opts,LineWidth,1];	dtsize=SetDefault[opts,DotWidth,.03];	parstyle=SetDefault[opts,ParPlotStyle,{}];	noshow=!SetDefault[opts,ParShow,True];	grlist=Graphics[ Join[parstyle,		{AbsoluteThickness[linesize],PointSize[dtsize]},	If[cccurve,ccurve[curve,{varmin,varmax},opts],{}],	If[dots,ddots[curve,{varmin,varmax},opts],		{}],	If[tans,ttans[curve,{varmin,varmax},opts],		{}],	If[norms || normals || unnorms,nnorms[curve,											{varmin,varmax},opts ,normals,unnorms ],{}]  ],		optins];		If[noshow,grlist,Show[grlist] ]]						ParLabOptions = {DotWidth,LineWidth,TanLength,					PlotPoints,NumDots,ParCurve,ParTans,ParDots,ParNorms,ParAcc,					ParUnitNorms,UnitNorm,ParPlotStyle,ParShow};ParLabDefaults = {AspectRatio->Automatic, Axes->True};FilterOpts[removeopts_,newdefaults_, optionlist_] := 			Sequence @@ Join[			Select[optionlist,Not[MemberQ[removeopts,First[#]]]&],			 newdefaults];SetDefault[optionlist_,option_,value_]:= (option /. 		  (Select[optionlist,First[#]===option &])		    /. option -> value);		    ccurve[curve_,{varmin_,varmax_},opts_]:=	Module[{numsteps,pointlist}, 		numsteps = SetDefault[opts,PlotPoints,100];				pointlist=Table[curve /. 			{t->tt*((varmax-varmin)/(numsteps))+varmin},			{tt,0,numsteps}]//N;		{Line[pointlist]} ]				ddots[curve_,{varmin_,varmax_},opts_]:=			Module[{numsteps,pointlist}, 		numsteps = SetDefault[opts,NumDots,50];		pointlist=Table[curve /. 			{t->tt*((varmax-varmin)/(numsteps))+varmin},			{tt,0,numsteps}]//N;					Table[{Hue[tt*(.6/numsteps)+.2]//N,					Point[pointlist[[tt+1]]]},					{tt,0,numsteps}] ]										PolarPlot[{rt_,theta_},{tmin_,tmax_},opts___]:=		ParPlot[{rt Cos[theta],rt Sin[theta]},			{tmin,tmax},opts]						nnorms[curve_,{varmin_,varmax_},opts_,normed_,unnormed_]:=			Module[{numsteps,pointlist,tanl,dc,ddc,totallength,unitnorm},								dc = D[curve,t]; 				numsteps = SetDefault[opts,NumDots,50];				unitnorm = SetDefault[opts,UnitNorm,.25];				If[normed || unnormed,ddc=D[dc/(dc.dc)^(1/2),t],ddc= D[dc,t]];				If[unnormed, ddc = ddc / Sqrt [ddc.ddc] * unitnorm ];		tanl = If[!unnormed,SetDefault[opts,TanLength,  1] /								numsteps /(varmax-varmin) //N,1];		pointlist=Table[curve /. 			{t->tt*((varmax-varmin)/(numsteps))+varmin},			{tt,0,numsteps}]//N;	Table[{Hue[tt*(.6/numsteps)+.2]//N,	Line[{pointlist[[tt+1]],pointlist[[tt+1]]+	tanl*ddc/.				{t->tt*((varmax-varmin)/(numsteps))+varmin}}]}//N,				{tt,0,numsteps}] ]			ttans[curve_,{varmin_,varmax_},opts_]:=			Module[{numsteps,pointlist,tanl,dc,totallength},						dc = D[curve,t]; 		numsteps = SetDefault[opts,NumDots,50];		tanl = SetDefault[opts,TanLength, 2.5] /								numsteps /(varmax-varmin) //N;		pointlist=Table[curve /. 			{t->tt*((varmax-varmin)/(numsteps))+varmin},			{tt,0,numsteps}] //N;	Table[{Hue[tt*(.6/numsteps)+.2],								Line[{pointlist[[tt+1]],														pointlist[[tt+1]]+tanl*dc/.				{t->tt*((varmax-varmin)/(numsteps))+varmin}}]},				{tt,0,numsteps}] ]													  					End[]Protect[ParPlot,t,Spirograph, Lissajous, BumpyCircle,PolarPlot,DotWidth,LineWidth,TanLength,					NumDots,ParCurve,ParTans,ParDots,ParNorms,ParAcc,					ParUnitNorms,UnitNorm,ParPlotStyle,ParShow]EndPackage[]