(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Prec[x_,digs_]:=10^(-digs) Round[x*10^(digs)] //N


(* ::Input::Initialization:: *)
Precweed[xlist_]:=Union[Prec[xlist,6]]


(* ::Input::Initialization:: *)
standhomoform[vect_]:=Prec[	
	(If[#[[-1]]==0,
		If[#[[2]]==0,
			{1,0,0},
		#/#[[2]]		],
	Append[Drop[#,-1]/#[[-1]],1]])&
	[Chop[vect/Max[Abs[vect]],10^-8]],			15]
	
weedhomovects[vectlist_]:= 
	Union[ standhomoform /@ vectlist ]


(* ::Input::Initialization:: *)
ApplyGroup[	depth_Integer,	group_,	objects_,
			operation_,	firstweedout_,	secondweedout_]	:= 
	(i=0;	oldlist=objects;	lastlist=objects;
	While[i<depth,
		lastlist= 
			firstweedout[Join @@ Outer[operation,group,lastlist,1]];
		oldlist= Union[lastlist,oldlist];
		i++];
		secondweedout[oldlist] )


(* ::Input::Initialization:: *)
ApplyGroup[depth_,group_,objects_,operation_]:=
	ApplyGroup[depth,group,objects,operation,Union[Chop[#,10^-4]]&,
		Union]


(* ::Input::Initialization:: *)
Group[depth_Integer,generators_,operation_,
		firstweedout_,secondweedout_]:=
	ApplyGroup[depth-1,generators,generators,operation,
		firstweedout,secondweedout]


(* ::Input::Initialization:: *)
Group[depth_Integer,generators_,operation_]:=
	ApplyGroup[depth-1,generators,generators,operation]


(* ::Input::Initialization:: *)





(* ::Input::Initialization:: *)
Rx= {	{-1,0,0},
		{0,1,0},
		{0,0,1}};
RotZ[th_]:={{Cos[th],-Sin[th],0},{Sin[th],Cos[th],0},{0,0,1}};
trans[th_]:={{1,0,0},{0,Cosh[th],Sinh[th]},{0,Sinh[th],Cosh[th]}}


(* ::Input::Initialization:: *)
PQGens[p_Integer?Positive,q_Integer?Positive]:= ({ Rx, RotZ[-Pi/q].Rx.RotZ[Pi/q],
	trans[-ArcCosh[Cot[Pi/p]Cot[Pi/q]]].
	RotZ[Pi/p].Rx.RotZ[-Pi/p].
	trans[ArcCosh[Cot[Pi/p]Cot[Pi/q]]]} //N) /; (1/p+1/q<.5)



(* ::Input::Initialization:: *)
rotgens[p_Integer?Positive,q_Integer?Positive]:=
	(({#[[1]].#[[2]],#[[2]].#[[3]],#[[3]].#[[1]]}&[
		PQGens[p,q]] )//Chop[#,10^-6]& )/; (p>2 && q>2)


(* ::Input::Initialization:: *)
Di[p_Integer?Positive]:=Di[p]=Group[ Ceiling[(p+1)/2], {Rx,RotZ[2 Pi/p]//N},Dot,
Union[Chop[#,10^-4]]&,Precweed]


(* ::Input::Initialization:: *)
MinkowskiProj[vect_]:=Drop[vect,-1]


(* ::Input::Initialization:: *)
KleinProj[vect_]:=Drop[vect,-1]/vect[[-1]]


(* ::Input::Initialization:: *)
PoincareProj[vect_]:= Drop[vect,-1]/
	((Sqrt[(vect[[-1]])^2-(vect[[1]])^2-(vect[[2]])^2])+vect[[-1]])


(* ::Input::Initialization:: *)
Eucd[vect1_,vect2_]:=(#.#)^(1/2) & [ vect1-vect2]


(* ::Input::Initialization:: *)
KleinDist[v1_,v2_,{e1_,e2_}]:=Abs[
	Log[(Eucd[v1,e2] Eucd[v2,e1])/ (Eucd[v1,e1] Eucd[v2, e2]) //N ]] 
	


(* ::Input::Initialization:: *)
KleinDist[v1_,v2_]:=KleinDist[v1,v2,PtEnds[v1,v2]]


(* ::Input::Initialization:: *)
PtEnds[v1_,v2_]:=Ends[{v1[[2]]-v2[[2]], -v1[[1]]+v2[[1]], 
 	-(v1[[2]] v2[[1]]) + v1[[1]] v2[[2]]}]


(* ::Input::Initialization:: *)
LineIT[matrixlist_]:= 
Inverse /@ (Transpose /@ (matrixlist//N)) 

LRx=Rx;

LRotZ[th_]:=RotZ[th]//N;

Ltrans[th_]:={{1,0,0},{0,Cosh[th],-Sinh[th]},{0,-Sinh[th],Cosh[th]}}//N

LPQGens[p_,q_]:= { LRx, LRotZ[-Pi/q].LRx.LRotZ[Pi/q],
	Ltrans[-ArcCosh[Cot[Pi/p]Cot[Pi/q]]].
	LRotZ[Pi/p].LRx.LRotZ[-Pi/p].
	Ltrans[ArcCosh[Cot[Pi/p]Cot[Pi/q]]]} //N
	
Lrotgens[p_,q_]:=({#[[1]].#[[2]],#[[2]].#[[3]],#[[3]].#[[1]]}&[
		LPQGens[p,q]])//Chop[#,10^-6]&
		
LDi[p_]:=Group[2 p, {LRx,LRotZ[2 Pi/p]} ,Dot,#&,Precweed] //N


(* ::Input::Initialization:: *)




(* ::Input::Initialization:: *)
Ends[{a_,b_,c_}]:= 
(dd1=a^2+b^2; dd2= Sqrt[dd1-c^2];
	 { {a c + b dd2, + b c - a dd2}, 
	{a c - b dd2,  b c + a dd2}}/dd1) //N


(* ::Input::Initialization:: *)
KleinLine[vect_]:= Line[Ends[vect]]


(* ::Input::Initialization:: *)
minrad=.003;
PoincareLine[{a_,b_,c_}]:=
	If[c==0,KleinLine[{a,b,c}],
	
		ends=Ends[{a,b,c}]; 
		center={a/c,b/c}; 
		radius=Sqrt[ #.# & [center-ends[[1]]]]; 
		If[radius< minrad, {},
		Circle[ center,radius,
		Evaluate[
		(thetas=(Sign[#[[2]]]ArcCos[#[[1]]/radius]& /@ 
				( #-center & /@ ends)); 
		dth=thetas[[2]]-thetas[[1]];
		If[dth>=Pi //N, {thetas[[2]],thetas[[1]]+2Pi //N},
		If[dth>=0,thetas,
		If[dth>=-Pi //N, {thetas[[2]],thetas[[1]]}, 
		{thetas[[1]],thetas[[2]]+2Pi//N}]]])]]
	
	 ]]
	
	
	




(* ::Input::Initialization:: *)
HLines[{pp_,qq_},dd_]:=
	ApplyGroup[1,LDi[qq]//N,#,Dot,weedhomovects,Precweed]& [
	
	ApplyGroup[dd,Lrotgens[pp,qq]//N,{LRotZ[ Pi/qq].{1,0,0}}//N,
	Dot,weedhomovects,Precweed] ];


(* ::Input::Initialization:: *)
minrad=.0;


(* ::Input::Initialization:: *)
ShowHLines[{pp_,qq_},dd_,method_]:=Show[Graphics[
Join[{AbsoluteThickness[1]},method/@ (HLines[{pp,qq},dd]),
{GrayLevel[.5], Circle[{0,0},1]}
], AspectRatio->Automatic,Axes->False]]


(* ::Input::Initialization:: *)
ShowHLines[Lines,Hlines_,method_]:=Show[Graphics[
Join[{AbsoluteThickness[.5]},method/@ (Hlines),
{GrayLevel[.5], Circle[{0,0},1]}
], AspectRatio->Automatic,Axes->False]]


(* ::Input::Initialization:: *)
MakeLine[homovect_]:=
	(homovect.{x,y,1}==0)


(* ::Input::Initialization:: *)
Intersect[homline_,homlist_]:= Select[

Join @@ (({x,y} /. 
Solve[{MakeLine[homline], MakeLine[# ]},{x,y}] &) /@ homlist),

#.#<1  & ]



