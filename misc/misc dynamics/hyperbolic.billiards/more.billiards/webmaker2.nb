(*^::[	Information =	"This is a Mathematica Notebook file.  It contains ASCII text, and can be	transferred by email, ftp, or other text-file transfer utility.  It should	be read or edited using a copy of Mathematica or MathReader.  If you 	received this as email, use your mail application or copy/paste to save 	everything from the line containing (*^ down to the line containing ^*)	into a plain text file.  On some systems you may have to give the file a 	name ending with ".ma" to allow Mathematica to recognize it as a Notebook.	The line below identifies what version of Mathematica created this file,	but it can be opened using any other version as well.";	FrontEndVersion = "Macintosh Mathematica Notebook Front End Version 2.2";	MacintoshStandardFontEncoding; 		fontset = title, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, e8,  24, "Times"; 	fontset = subtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, e6,  18, "Times"; 	fontset = subsubtitle, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeTitle, center, M7, italic, e6,  14, "Times"; 	fontset = section, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, grayBox, M22, bold, a20,  18, "Times"; 	fontset = subsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, blackBox, M19, bold, a15,  14, "Times"; 	fontset = subsubsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, whiteBox, M18, bold, a12,  12, "Times"; 	fontset = text, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = smalltext, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  10, "Times"; 	fontset = input, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeInput, M42, N23, bold, L-4,  12, "Courier"; 	fontset = output, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-4,  12, "Courier"; 	fontset = message, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, R32768, L-4,  12, "Courier"; 	fontset = print, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-4,  12, "Courier"; 	fontset = info, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, B32768, L-4,  12, "Courier"; 	fontset = postscript, PostScript, formatAsPostScript, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeGraphics, M7, l34, w282, h287,  12, "Courier"; 	fontset = name, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, italic,  10, "Geneva"; 	fontset = header, inactive, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = leftheader, inactive, L2,  12, "Times"; 	fontset = footer, inactive, noKeepOnOnePage, preserveAspect, center, M7,  12, "Times"; 	fontset = leftfooter, inactive, L2,  12, "Times"; 	fontset = help, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  10, "Times"; 	fontset = clipboard, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = completions, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special1, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special2, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special3, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special4, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	fontset = special5, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7,  12, "Times"; 	paletteColors = 128; currentKernel; ]:[font = input; initialization; preserveAspect]*)n[x_]:=N[x,10](*:[font = subsubsection; inactive; preserveAspect; startGroup]Hyperbolic stuff:[font = text; inactive; preserveAspect; startGroup]Hyperbolic Geometry:We assume that VERTICAL GEODESICS will be present. This assumption will speed computations.  In practice,  this will be true if none present initially.First Given two points z=A+iC  and w=B+iD,    t + i0  is the center of the hyperbolic line inthe upper half plane model that runs between w and z;   R is the radius of this line.More formally::[font = input; initialization; preserveAspect]*)Cent[{A_,C_},{B_,D_}]:=	n[(A^2 - B^2 + C^2 - D^2)/(2*(A - B))](*:[font = input; initialization; preserveAspect]*)Rad[{A_,C_},{B_,D_}]:=n[Abs[(	(A^2-2*A*B+B^2+C^2-2*C*D+D^2)* 	(A^2-2*A*B+B^2+C^2+2*C*D+D^2)	)^(1/2)  /(2(-A + B))]](*:[font = text; inactive; preserveAspect]Use a mobius transformationline  zw, with rt hand end b=T+R and left hand end a=T-R  (thus azwb)to a->0, z->i , w->Phi[w,z] b->infinityThen take Phi^-1 of w^2.:[font = input; initialization; preserveAspect]*)phi[x_,Z_]:=(x+r-t)(Z-r-t)/(x-r-t)/(Z+r-t)(*:[font = input; initialization; preserveAspect]*)phiinv[x_,Z_]:=Block[{p1=n[phi[1,Z]],p0=n[phi[0,Z]],	pi=n[(Z-r-t)/(Z+r-t)]},	(p1-pi)(x-p0)/(p1-p0)/(x-pi)](*:[font = text; inactive; preserveAspect]And so: we now give the eqn for the point   x  that lies on zw  d(z,w) beyond w:z={A,C} "=" A+iC         w={B,D}:[font = input; initialization; preserveAspect]*)NewPoint[{z_,w_}]:=Block[{A=z[[1]],B=w[[1]],				C=z[[2]],D=w[[2]],				r=Rad[w,z],t=Cent[w,z],Z=A+I*C},		If[B===A, n[{B,D^2/C}], 		Block[{NP=n[phiinv[n[phi[B+I*D,Z]^2],Z]]},			{Re[NP],Im[NP]} ],{0} ]](*:[font = input; preserveAspect; endGroup; endGroup]:[font = subsubsection; inactive; preserveAspect; startGroup]Polygons:[font = text; inactive; preserveAspect; startGroup]We now consider a polygonWe need various data: edges, endpoints of edges, etc:[font = text; inactive; preserveAspect]Each line, in turn, has associated with it  (at least!) the following useful information:(1) corner p1, (2) corner p2, (3) radius, (4) center, (5)"p3 is below line" (true/false or right/left if vertical), (6) start and  (7) stop of  theta in parametric plot, (8) radius squared:[font = input; initialization; preserveAspect]*)entry[p1_,p2_,p3_]:=Block[{r=Rad[p1,p2],rr=r^2,c=Cent[p1,p2]}	,Join[{p1,p2,r,c},	 If[c===inf, If[p3[[1]]>p1[[1]],		{Right,p1[[1]],p2[[1]],inf},{Left,p1[[1]],p2[[1]],inf},{yyy}]										,{((p3[[1]]-c)^2+p3[[2]]^2)<rr,ArcCos[(p1[[1]]-c)/r],		ArcCos[(p2[[1]]-c)/r],rr}, {xxx}]]](*:[font = input; initialization; preserveAspect]*)makestrand[p1_,p2_,cone_]:=Block[	{r=Rad[p1,p2],rr=r^2,c=Cent[p1,p2]}	,{p1,p2,r,c,ArcCos[(p1[[1]]-c)/r],		ArcCos[(p2[[1]]-c)/r],cone}](*:[font = text; inactive; preserveAspect]edges[{ {x1,y1}, {x2,y2}, ...}}]     returns a list of {#entries, entry1, entry2, ...}:[font = input; initialization; preserveAspect; endGroup; endGroup]*)edges[p_]:=Block[{len=Length[p]},	Join[{len},Table[entry[p[[k-2]],p[[k-1]],p[[k]] ],{k,3,len}],{ entry[p[[len-1]],p[[len]],p[[1]] ],entry[p[[len]],p[[1]],p[[2]] ]} ]](*:[font = subsubsection; inactive; preserveAspect; startGroup]And for graphing::[font = input; initialization; preserveAspect]*)PlotLines[e_]:=Join[Table[If[e[[k]][[3]]===inf, 	{e[[k]][[1]][[1]],10(theta)},	{e[[k]][[3]]Cos[Pi*theta]+e[[k]][[4]], 			e[[k]][[3]]Sin[theta*Pi]	},{1,theta}	] ,{k,2,Length[e]}]  ](*:[font = input; initialization; preserveAspect; endGroup]*)PlotStrands[e_]:=Table[	{e[[k,3]]Cos[theta*e[[k,5]]+(1-theta)e[[k,6]]]+e[[k,4]], 			e[[k,3]]Sin[theta*e[[k,5]]+(1-theta)e[[k,6]]]} ,							{k,1,Length[e]}]  (*:[font = subsubsection; inactive; preserveAspect; startGroup]Iterations:[font = text; inactive; preserveAspect; startGroup]Given a polygon (and all the extra data with it)  a point, and ASSUMING same cyclic motionas order of vertices, find the vertex of poly through which to move.Whereis1 returns a list of {T/F,T/F,T/F} where T in spot n means point x is to the SAME side ofline n as the triangle.  If x is inside polygon, will return all trues.  Otherwise, a cyclic permutation of something like{T,T,T,F,F,F,F}. The position of the LAST false is the index of the vertex tomove through.:[font = input; initialization; preserveAspect]*)tester[edge_,x_]:=Block[	{radius=(x[[1]]-edge[[4]])^2+x[[2]]^2},		If[radius===edge[[8]] , False,		(radius<edge[[8]])===edge[[5]]   ]]	(*:[font = input; initialization; preserveAspect; endGroup; endGroup]*)WhereIs[x_,polygon_]:=	Block[{i,mm=polygon[[1]]},	If[ tester[polygon[[2]],x],				i=mm;While[tester[polygon[[i+1]],x] && i>=2, i--]; 				If[i===mm,1,If[i>1,i+1,"inside"]],				i=1; While[(!tester[polygon[[i+1]],x]) && i<mm, i++]			;i 				]](*:[font = subsubsection; inactive; preserveAspect; startGroup]Now we iterate::[font = input; initialization; preserveAspect]*)npt[y_]:=	NewPoint[{y,trian[[WhereIs[y,trian] +1,1]]}](*:[font = input; initialization; preserveAspect]*)Iterate[triang_,x_,max_]:=Block[{trian=triang},NestList[npt, x, max]](*:[font = input; initialization; preserveAspect; endGroup]*)PlotIterates[triang_,x_,max_,range_]:= Show[Graphics[	{AbsolutePointSize[.25],Evaluate [	Point /@ Iterate[triang,x,max] ]},Axes->True,		AxesStyle->AbsoluteThickness[.01],PlotRange->range],ParametricPlot[Evaluate[PlotLines[triang]],{theta,0,1},	PlotStyle->AbsoluteThickness[.01]] ](*:[font = subsection; inactive; preserveAspect; startGroup]Examples:[font = input; preserveAspect; startGroup]b=n[edges[{{10,10},{4,4},{6,2}}]]:[font = output; output; inactive; preserveAspect; endGroup]N≠0"      ∞VÚ0ZÃÄZÃ@100              pVÚ0ZÃ†      `ZÃ®.254      PVÚ0ZÃ¿ZÃÄ   ZÃH^X      0VÚ0ZÃ‡ZÃ†   ZÃËN≠0"      VÚ0ZÕ ZÃ¿150              VÚ0ZÕ       ‡ZÕ(.67      –VÚ0ZÕ@ZÕ    ZÃ»^X      ∞VÚ0ZÕ`ZÕ    ZÕhN≠0"      êVÚ0ZÕÄZÕ@200              pVÚ0ZÕ†      `ZÕ®711       PVÚ0    ZÕÄ   ZÕH^X      0  8.74576 .14969 L.73577 .13831 L.72671 .12571 L.71866 .11201 L.71171 .09734 L.70592 .08186 LMistroke.70348 .073      ∞136 .06571 L.69955 .05743 L.69806 .04905 L.6969 .04059 L.69644 .03633 L.69606 .03206 L.69577 .02777 L.69566 .02563 L.69556 .02348 L.69549 .0213      46 .02026 L.69543 .01919 L.69541 .01811 L.69541 .01757 L.6954 .01704 L.69539 .0165 L.69539 .01596 L.69539 .01543 L.69539 .014;[o]{3., {{10., 10.}, {4., 4.}, 10.7703296142690080625, 14., True,     1.95130270390726150553, 2.7610862764774283522, 116.},    {{4., 4.}, {6., 2.}, 4.4721359549995793928, 2., False,     1.10714871779409050302, 0.4636476090008061162, 20.},    {{6., 2.}, {10., 10.}, 14.142135623730950488, 20., False,     2.9996955989856293156, 2.3561944901923449288, 200.}}:[font = input; preserveAspect; endGroup]PlotIterates[b,{9.96,9.9},150,Automatic]:[font = subsection; inactive; preserveAspect; startGroup]The Web:[font = text; inactive; preserveAspect]We need one more object, and two operations: find and chop.The Web is a collection of strands, each lying completely within a particular cone::[font = text; inactive; preserveAspect]strand[end1, end2, rradius, ccenter, start, stop, cone]:[font = text; inactive; preserveAspect; startGroup]preliminary::[font = input; initialization; preserveAspect; endGroup]*)Intersect[strand1_,strand2_]:=	Block[{	 C1=strand1[[4]],	 C2=strand2[[4]],	 R1=strand1[[3]],	 R2=strand2[[3]],	 xint=(C1^2-C2^2-R1^2+R2^2)/2/(C1-C2),	 discrim=R1^2-(xint-C1)^2},      n[{xint, If[ discrim<0,"miss", Sqrt[discrim]]}]]	(*:[font = input; initialization; preserveAspect]*)ConeStrands[polygon_]:=Table[  Block[{				ithedge=polygon[[i+1]]},Block[{				rr=ithedge[[3]],				cc=ithedge[[4]],				stt=ithedge[[6]],				stp=ithedge[[7]],				ends=If[stt<stp,    								(*ie ith line reads right to left*)	 				{ {ithedge[[1]],{rr*Cos[.001]+cc,rr*Sin[.001]}},	 						{stt,.001} },	 				{ { {cc-rr*Cos[.001],rr*Sin[.001]},ithedge[[1]]},	 						{3.140592653589793238,stt} } (*note that ends always read left to right*)]	 	},  	 		 	Join[ends[[1]],{rr,cc},ends[[2]],{i+1}   ]	]],{i,1,polygon[[1]]} ]	(*;[s]5:0,0;194,1;229,0;400,1;444,0;532,-1;2:3,12,10,Courier,1,12,0,0,0;2,12,9,Times,0,12,0,0,0;:[font = input; initialization; preserveAspect]*)FirstStrands[polygon_]:=Table[Block[{				ithedge=polygon[[i+1]]},Block[{				rr=ithedge[[3]],				cc=ithedge[[4]],				stt=ithedge[[6]],				stp=ithedge[[7]],				ends=If[stt<stp,    								(*first end is near infinity *)						{ { {cc-rr*Cos[.00001],rr*Sin[.00001]},ithedge[[2]]},	 						{3.141582653589793238,stp} },	 				{ { {rr*Cos[.00001]+cc,rr*Sin[.00001]},ithedge[[2]]},	 						{.00001,stp} }	 			]},  	 		 	Join[ends[[1]],{rr,cc},ends[[2]],	 		{WhereIs[ends[[1,1]],polygon]},{"infend"} ]	]],{i,1,polygon[[1]]} ](*;[s]3:0,0;193,1;224,0;531,-1;2:2,12,10,Courier,1,12,0,0,0;1,12,9,Times,0,12,0,0,0;:[font = text; inactive; preserveAspect]Given strand, construct its image, then chop:[font = input; preserveAspect; startGroup]DivideStrand[oldstrand_,cutstrand_,cone1_,cone2_]:=  Block[   {cutpt =  Intersect[oldstrand,cutstrand] },   Block[{ct1=cutpt[[1]],ct2=cutpt[[2]]},    If[ ct2==="miss", {oldstrand},   If[ (ct1===oldstrand[[1]][[1]]) ||		(ct1===oldstrand[[2]][[1]]), 			{Join[oldstrand[[{1,6}]],			 {If[ ct1===oldstrand[[1]][[1]], cone1,cone2 ] },			 {If[ Length[oldstrand]===8, "infend"]}]},		  Block[  {ctheta=  	ArcCos[(ct1-oldstrand[[4]])/oldstrand[[3]]]}	  ,   { If[Length[oldstrand]===8,{oldstrand[[1]],cutpt,  		oldstrand[[3]],oldstrand[[4]],  			oldstrand[[5]],ctheta,cone1,"infend"},  		{oldstrand[[1]],cutpt,  		oldstrand[[3]],oldstrand[[4]],  			oldstrand[[5]],ctheta,cone1}],  	{cutpt,oldstrand[[2]],oldstrand[[3]],oldstrand[[4]],  		ctheta,oldstrand[[6]],cone2}  } ]]]]]:[font = message; inactive; preserveAspect; endGroup]General::spell1:    Possible spelling error: new symbol name "ctheta"     is similar to existing symbol "theta".:[font = input; preserveAspect; endGroup]NewStrands[oldstrand_,polygon_,TheConeStrand_]:=	Block[	{ nend1=		NewPoint[{oldstrand[[1]],			polygon[[oldstrand[[7]]+1,1]]  }  ],	 newend2=		NewPoint[{oldstrand[[2]],			polygon[[oldstrand[[7]]+1,1]]  }  ]},				Block[{	 cone1=WhereIs[nend1,polygon],	 cone2=WhereIs[newend2,polygon],	 cc=Cent[nend1,newend2],	 rr=Rad[nend1,newend2],	 	 sttp= ArcCos[(newend2[[1]]-cc)/rr]},	 	Block[{infinitend=(Length[oldstrand]===8)},	Block[{		   newend1=If[infinitend, 		   	If[nend1[[1]]<newend2[[1]],		   	{cc-rr*Cos[.00001],rr*Sin[.00001]},		   	{cc+rr*Cos[.00001],rr*Sin[.00001]}],		   nend]		   sttrt= ArcCos[(newend1[[1]]-cc)/rr]},	Block[{newstrand1=Join[		{newend1,newend2,rr,cc,sttrt,sttp,cone1},	If[infinitend,{"infend"},{}]]},   	 If[  cone1===cone2 , 	 {newstrand}, 		 		 If[ (cone1===1 && cone2===2)||(cone1===2 && cone2===1),	DivideStrand[{newstrand},		TheConeStrand[[1]],cone1,cone2],If[ (cone1===2 && cone2===3)||	(cone1===3 && cone2===3),	DivideStrand[{newstrand},		TheConeStrand[[2]],cone1,cone2],(* then (cone1===1 && cone2===3)||   (cone1===3 && cone2===1) *)		DivideStrand[{newstrand},		TheConeStrand[[3]],cone1,cone2],	"uhoh"]]]		 		 		]]]]]		 :[font = text; inactive; Cclosed; preserveAspect; startGroup]Other try:[font = text; inactive; preserveAspect; endGroup]Initially:  (totally insensitive)If[ cone1<cone2,  "heya" 	Block[{strandstring,cuttingstring,i},	strandstring={}; 	cuttingstring={newend1,newend2,rr,cc,sttrt,sttp,"skip"};	i=cone1+1;		While[i<=cone2, Block[		{cuttings=DivideStrand[		  cuttingstring,TheConeStrand[[i]],i-1,i]},		strandstring=Join[cuttings[[1]],strandstring];		cuttingstring=cuttings[[2]] ];i++];strandstring]  *),		If[ cone1>cone2,  "hoya" (*	Block[{strandstring,cuttingstring,i},	strandstring={}; 	cuttingstring={newend1,newend2,rr,cc,sttrt,sttp,"skip"}; 	i=cone2;		While[i>cone1, Block[		{cuttings=DivideStrand[		  cuttingstring,TheConeStrand[[i]],i-1,i]},	 		strandstring=Join[cuttings[[1]],strandstring];		cuttingstring=cuttings[[2]] ];i--];strandstring] *)]]  	]		 ]]	:[font = input; preserveAspect]nnnewlist[oldlist_]:=	Join @@ Table[		NewStrands[oldlist[[i]],bb,conelist],		{i,1,Length[oldlist]} ]:[font = input; preserveAspect]StrandList[b_,depth_]:=Block[{	conelist=ConeStrands[b],	startlist=FirstStrands[b],	bb=b},	Join @@ NestList[nnnewlist, startlist,depth]]^*)