(*^::[	Information =	"This is a Mathematica Notebook file.  It contains ASCII text, and can be	transferred by email, ftp, or other text-file transfer utility.  It should	be read or edited using a copy of Mathematica or MathReader.  If you 	received this as email, use your mail application or copy/paste to save 	everything from the line containing (*^ down to the line containing ^*)	into a plain text file.  On some systems you may have to give the file a 	name ending with ".ma" to allow Mathematica to recognize it as a Notebook.	The line below identifies what version of Mathematica created this file,	but it can be opened using any other version as well.";	FrontEndVersion = "NeXT Mathematica Notebook Front End Version 2.2";	NeXTStandardFontEncoding; 		fontset = title, inactive, noPageBreakBelow, noPageBreakInGroup, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, L1, e8,  24, "Times"; ;	fontset = subtitle, inactive, noPageBreakBelow, noPageBreakInGroup, nohscroll, preserveAspect, groupLikeTitle, center, M7, bold, L1, e6,  18, "Times"; ;	fontset = subsubtitle, inactive, noPageBreakBelow, noPageBreakInGroup, nohscroll, preserveAspect, groupLikeTitle, center, M7, italic, L1, e6,  14, "Times"; ;	fontset = section, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, grayBox, M22, bold, L1, a20,  18, "Times"; ;	fontset = subsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, blackBox, M19, bold, L1, a15,  14, "Times"; ;	fontset = subsubsection, inactive, noPageBreakBelow, nohscroll, preserveAspect, groupLikeSection, whiteBox, M18, bold, L1, a12,  12, "Times"; ;	fontset = text, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12;	fontset = smalltext, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  10, "Times"; ;	fontset = input, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeInput, M42, N23, bold, L1,  12, "Courier"; ;	fontset = output, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L-5,  12, "Courier"; ;	fontset = message, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L1,  12, "Courier"; ;	fontset = print, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L1,  12, "Courier"; ;	fontset = info, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeOutput, M42, N23, L1,  12, "Courier"; ;	fontset = postscript, PostScript, formatAsPostScript, output, inactive, noPageBreakInGroup, nowordwrap, preserveAspect, groupLikeGraphics, M7, l34, w282, h287, L1,  12, "Courier"; ;	fontset = name, inactive, noPageBreakInGroup, nohscroll, preserveAspect, M7, italic, B65535, L1,  10, "Times"; ;	fontset = header, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, italic, L1,  12, "Times"; ;	fontset = leftheader,  12;	fontset = footer, inactive, nohscroll, noKeepOnOnePage, preserveAspect, center, M7, italic, L1,  12, "Times"; ;	fontset = leftfooter,  12;	fontset = help, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12;	fontset = clipboard, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12;	fontset = completions, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12, "Courier"; ;	fontset = special1, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12;	fontset = special2, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12;	fontset = special3, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12;	fontset = special4, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12;	fontset = special5, inactive, nohscroll, noKeepOnOnePage, preserveAspect, M7, L1,  12;	paletteColors = 128; automaticGrouping; remoteKernel = "abel"; ]:[font = title; inactive; preserveAspect; startGroup] Intro To Mathematica;[s]2:0,0;10,1;21,-1;2:1,21,16,Times,1,24,0,0,0;1,22,17,Times,3,24,0,0,0;:[font = subsubtitle; inactive; preserveAspect]June 1995,  Chaim Goodman-Strauss:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Getting Started :  double click on the down arrow at right:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]The Note book interface:[font = text; inactive; preserveAspect; endGroup]First off,  this is a notebook.  It is divided into cells,  arranged hierarchically.   The cells are  usually  Titles (above),  Text (like this), or Input,  ( in  a while,   below)You can  select the cells type from the   Mathematica   menu bar:  Cell     ->    Style Inspector....brings up the style inspector panel.  Cell Style is the relevant  option here.    Keyboard shortcuts are given there as well.There's lots more, but  the notebook is primarily a   user-friendly front end;  the actual "kernel"  may be running on another machine entirely.  (In fact, the kernel for this notebook is running on the machine abel.  Since many of you might be looking at this at the same time.   now would be a  good time to change the kernel to another machine.;[s]7:0,0;229,1;240,2;255,3;289,4;630,5;634,6;772,-1;7:1,11,8,Times,0,12,0,0,0;1,10,8,Times,3,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Setting the The  Kernel's Host:[font = text; inactive; preserveAspect; endGroup]1) figure out a machine to run the kernel on.  NeXT's are bad, IRISes and Suns are good.  For a list of hosts,  in a Unix shell,  type  :less     /usr/local/lib/mathematica/distrib/2.2/iris/Install/mathpassA long list of machine names will come up; the first two clumps are Irises and Suns, the last clump is NeXTs--- so pick one of the names near the top or middle Get a machine name,  say abelthen type       rsh    abel  w or                   rsh   abel  ps  -aor                  rlogin   abel         and  then    top  or                   rup   abel     to see if the machine is very busy.2) When that's all settled,  from the Mathematica menu bar   select:Action     ->     Kernels and Tasks....On the panel that comes up,  click  New Kernel,in the Connection Name  slot type the computer's nameClick  Launch Kernel on ......  A Remote ComputerType the name in again in...  Remote Computer to run Kernel on ....Click Set the connection as.... The Notebooks KernelThe Click                                 Launch KernelThis panel is also useful for aborting  tasks that have gotten out of hand , or even killing off the kernel if the situation seems dire.   It is also useful to kill the kernel every once in a while if your calculations use a lot of memory, or to clear out variable names.;[s]32:0,0;115,1;130,2;141,3;146,4;149,5;150,6;210,7;211,8;372,9;398,10;402,11;419,12;433,13;456,14;474,15;495,16;509,17;529,18;533,19;557,20;568,21;610,22;612,23;681,24;720,25;757,26;767,27;872,28;941,29;1188,30;1323,31;1325,-1;32:1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]The Function Browser     :   An On Line Reference:[font = text; inactive; preserveAspect]Now   this is great!   Look under   Info  -> Function Browserto get the  Function Browser panel.  It should be pretty obvious how it works.  The other primary source is the shelf full of Mathematica   manuals on the book cases in the Big Room.   Pages 750-905  are basically the same thing as the Browser, but organized differently.     The input   ??foo   gives info about  foo 	       ??foo*  gives info about the commands  beginning foo	       ??*foo*  gives info about all commands  conataining the string foo;[s]11:0,0;38,1;63,2;191,3;202,4;357,5;362,6;396,7;404,8;457,9;464,10;524,-1;11:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect; endGroup; endGroup] ??Cos  :[font = section; inactive; Cclosed; preserveAspect; startGroup]Doing Stuff:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Lets Go!:[font = text; inactive; preserveAspect]Welcome to Mathematica;    To evaluate these cells, hit the Enter key with the cursor in the  cell or the whole cell selcted.(The Return key is merely a carriage return.   Shift-Return  is the same as Enter);[s]11:0,0;12,1;23,2;63,3;68,4;134,5;140,6;176,7;189,8;205,9;210,10;214,-1;11:1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect]3+7 :[font = input; preserveAspect]Sin[37Pi/16]:[font = input; preserveAspect]3^56 :[font = input; preserveAspect]Prime[23912827]   (*Gives the nth prime #.  By the way,					this is another way to put in 					 comments *):[font = input; preserveAspect]Factor[192-1940.08*x-519.4*x^2+1.48*x^3+ 0.52*x^4] :[font = text; inactive; preserveAspect]This is fancy::[font = input; preserveAspect]a=2;x=(a+Cos[u/2]Sin[t]-Sin[u/2]Sin[2t])Cos[u];y=(a+Cos[u/2]Sin[t]-Sin[u/2]Sin[2t])Sin[u];z=Sin[u/2]Sin[t]+Cos[u/2]Sin[2t];ParametricPlot3D[  	{x,y,z},	{t,0,2Pi},{u,0,2Pi}]	:[font = text; inactive; preserveAspect]  Note the kind of "=" sign used. This means    "set left  equal to right hand side."  You can put lots of stuff in one cell,    seperated by carriage returns or by  semicolons.    (A semicolon  suppresses the output-- sometimes very useful!)         :[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Do This!:[font = input; preserveAspect]x=6 :[font = input; preserveAspect]x:[font = input; preserveAspect]Clear[a,x,y,z]     :[font = input; preserveAspect]x:[font = input; preserveAspect; endGroup]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]More:[font = text; inactive; preserveAspect]  Great!   But because mathematica treats   things symbolically as much  as possible,  it did not actually compute  Sin[37Pi/16];   also, "numbers" are typically  16 digits long, so 3^56  was also a symbolic answer.   N[expr]   gives a numerical result of expr;   Also Chop[expr,precision]  can be useful as you'll  eventually see:;[s]7:0,0;219,1;227,2;257,3;261,4;271,5;291,6;333,-1;7:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect]N[Sin[37Pi/16]]  N[ 3^56 ]       (*note you can put many commands in 					one cell *):[font = input; preserveAspect; endGroup; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Lists,  Matrices and Arrays:[font = text; inactive; preserveAspect]In Mathematica  Lists, matrices and arrays  are all the same!   Lists are the primary data structure, and  list operations are some of the fundamental building blocks for programming.There are four kinds of braces in mathematica:(    )         group  stuff together[    ]          of,   as in f of x    f[x]{    }        List  [[    ]]       Part  ;[s]5:0,0;3,1;14,2;186,3;353,4;356,-1;5:1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect]Rot7 =  N[ { {Cos[Pi/7], Sin [Pi/7] }, 			{-Sin[Pi/7],Cos[Pi/7]}} ] :[font = input; preserveAspect]MatrixForm[Rot7]   (*MatrixForm  makes nice output*) :[font = input; preserveAspect]Rot7[[2]]     (* second term of Rot7 *)Rot7[[2]]  [[1]]   			(* first term of second term of Rot7 *)Rot7[[2,1]]   (* ditto *)Rot7[[-1]]		(*last term in the list	 *):[font = input; preserveAspect]{a,b,{c,d},f,g} [[{1,3}]]    (* items 1-3 in a list*):[font = text; inactive; preserveAspect]:[font = text; inactive; preserveAspect]We can do the usual matrix stuff: :[font = input; preserveAspect]3 Rot7   (*mult by a scalar, or can think of this as			multiplying everything in a list or array *):[font = input; preserveAspect]Det[Rot7]         (*Determinate*)Transpose [Rot7]:[font = input; preserveAspect]Rot7Inverse = Inverse [Rot7] :[font = text; inactive; preserveAspect]Matrix multiplication::[font = input; preserveAspect]Rot7Inverse.Rot7:[font = text; inactive; preserveAspect]HEY!  WAait a minute!   That should have given  the identity:  {{1,0},{0,1}}!The trouble is round-off error.  This is why  Chop is useful;[s]3:0,0;124,1;129,2;138,-1;3:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect]Chop [ Rot7Inverse.Rot7  , 10^-10]   					(*chop after 10^-10*) :[font = input; preserveAspect; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]More List Operations:[font = text; inactive; preserveAspect]NOTE THE DIFFERENCES!:[font = input; preserveAspect]Join [{a,{b,d}},{e,f,a}]:[font = input; preserveAspect]Union[{a,{b,d}},{e,f,a}]:[font = input; preserveAspect]Flatten [{a,{b,d}},{e,f,a}]:[font = input; preserveAspect]Append[{a,{b,d}},{e,f,a}]:[font = input; preserveAspect]Prepend[{a,{b,d}},{e,f,a}]  				(*this one may seem backwards!*):[font = text; inactive; preserveAspect]Still more operations    are available.   :[font = text; inactive; preserveAspect]Here are a few more::[font = input; preserveAspect]RotateRight[{a,b,c,d,e},1]:[font = input; preserveAspect]Drop[{a,b,c,d,e},2]:[font = input; preserveAspect]Drop[{a,b,c,d,e},{2,3}]:[font = input; preserveAspect]Length[{a,b,c,d,e}]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Very Useful::[font = input; preserveAspect]Table[x^2, {x,-2,2}] Table[x^2, {x,1,9,2}]:[font = input; preserveAspect; endGroup; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Solving Equations,  Taking Integrals, Plotting functions,Manipulating polynomials:[font = input; preserveAspect]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Polynomials:[font = input; preserveAspect]poly= (a*x+b*y)(c*x+d*y)^3  :[font = input; preserveAspect]Expand[poly] :[font = input; preserveAspect]Factor[Expand[poly]] :[font = text; inactive; preserveAspect]See also  Simplify     Collect     ;[s]3:0,0;10,1;36,2;37,-1;3:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect; endGroup]Simplify[(Cos[u]^2*Cos[v]^4 + 			Cos[v]^4*Sin[u]^2 +  			(Cos[u]^2*Cos[v]*Sin[v] + 			Cos[v]*Sin[u]^2*Sin[v])^2)^(1/2)] :[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Solving Equations:[font = text; inactive; preserveAspect]Note the new kind of equals sign.  ==    is a test for equality.  We'll come back to that.:[font = input; preserveAspect; endGroup]Solve[	{ x+3y - z == 0,	 -x -2 y +z ==3,	  3 x == 4 y     } , {x,y,z}]  	  :[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Differentiation, Definite Integrals,  Indefinite Integrals:[font = input; preserveAspect]D[ {x^2+x*y-1,3x} , x]D[ {x^2+x*y-1,3x} , y] :[font = input; preserveAspect]Integrate[{x^2+x*y-1,3x} , y] :[font = input; preserveAspect]NIntegrate[Exp[x^2],{x,0,3}] :[font = input; preserveAspect; endGroup; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Logical operations, testing:[font = input; preserveAspect]:[font = input; preserveAspect]True || False  (* Or[expr1, expr2] === (expr1 || expr2) *)True && False  (* And[expr1, expr2] === (expr1 && expr2) *)!True			(* Not[expr] === (!expr) *):[font = input; preserveAspect]:[font = input; preserveAspect]3==7 :[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]If statements are obviously useful::[font = input; preserveAspect]If[3==7,dance,shout]If[3==1.5+1.5,dance,shout]If[dogsfly, dance, shout, whistle]	(*dogsfly is neither True nor False *) :[font = input; preserveAspect; endGroup]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]More::[font = input; preserveAspect]Or[expr1, expr2] === (expr1 || expr2)  :[font = input; preserveAspect]3<=7 :[font = input; preserveAspect]N[Sqrt[19]]<4:[font = input; preserveAspect]IntegerQ[.5]:[font = input; preserveAspect]EvenQ[34893084309822]:[font = input; preserveAspect]PrimeQ[583875211123](*just for reference: *)FactorInteger[583875211123] :[font = input; preserveAspect; endGroup]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]A Subtlety:   ===   vs  ==:[font = text; inactive; preserveAspect]There  are four kinds of equal signs.   Two set things equal to each other;  two test for  equality.:[font = text; inactive; preserveAspect]  =      "set   left side equal to right"   :=      "wait;  when the left side is evaluated, then set left equal to right"                          ==     "true,  if left equals right,  nothing otherwise"          ===   "true, if left equals right,  false otherwise"                    Thus::[font = input; preserveAspect]expr== exprexpr===expr :[font = input; preserveAspect]expr1==expr2expr1===expr2 :[font = text; inactive; preserveAspect]This is very important when concerned with flow control in an If statement:[font = input; preserveAspect]If[dogs==whistle, dance, shout, flip] If[dogs===whistle, dance, shout, flip]:[font = text; inactive; preserveAspect]Figure this out::[font = input; preserveAspect](expr1==expr1)===(expr1===expr1)(expr1==expr1)==(expr1===expr1) :[font = input; preserveAspect](expr1==expr2)===(expr1===expr2) (expr1==expr2)==(expr1===expr2) :[font = input; preserveAspect; endGroup; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Functions, and definitions (the programming environment); flow control:[font = text; inactive; preserveAspect]The main thing  is that your definitions  ARE the program.   It is a mistake to use   BASIC as a model;Pascal and C are also pretty different. In particular, there are no GoTo statements andFor,  While and Do   are best used rarely.      Mathematica is pretty much a snazzed up LispThink of things in terms of lists of instructions acting on lists.  Lists are the main structures!;[s]3:0,0;242,1;253,2;387,-1;3:1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Defining functions:[font = text; inactive; preserveAspect]There is a lot to this;   here are some basics.   :[font = input; preserveAspect]  f[x] = 3x    (*these are explicit definitions of f for				particular values *)  f[x] f[y]         (*this  prob wasn't what you wanted*):[font = input; preserveAspect]g[x_]:= x^2    (*this is a more general definition*) g[3]g[sza]:[font = text; inactive; preserveAspect]Your definitions can be quite specific::[font = input; preserveAspect]h[x_Integer]:=Mod[x,5]h[x_List]:=Length[x] :[font = input; preserveAspect]h[34] :[font = input; preserveAspect; endGroup]h[{a,d,s,{a,d}}] :[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Scoping:[font = input; preserveAspect](*The last output is what's returned.     Here y,z have been affected globally:*)  A[x_Integer]:= ( 	y=If[EvenQ[x],x/2,(x+1)/2]; 	z=Prime[y];	x*y*z):[font = input; preserveAspect]A[3]yz:[font = input; preserveAspect]Clear[x,y,z] (*Here, y is local, z is global *)B[x_Integer]:=Block[{y=If[EvenQ[x],x/2,(x+1)/2]},	z=Prime[y];x*y*z]:[font = input; preserveAspect; endGroup]B[3] yz:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]For While If Do  :[font = input; preserveAspect]Clear[z] :[font = input; preserveAspect](z=2;i=1;While[i<10,z= z^2-z+1;i++];z) (* My guess is that these are pretty transparent *):[font = input; preserveAspect; endGroup]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Nest[f, expr,n]     and   NestList[f, expr,n]:[font = text; inactive; preserveAspect]This is very useful for recursion::[font = input; preserveAspect]Nest[f,2,4]  :[font = input; preserveAspect] :[font = input; preserveAspect]NestList[f,2,4]  :[font = input; preserveAspect; endGroup; endGroup]f[z_]:=z^2-z+1;NestList[f,2,5] :[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Patterns:[font = text; inactive; preserveAspect]I  myself   don't    use this often but it is one of the powerful aspects of Mathematica ;[s]3:0,0;78,1;89,2;90,-1;3:1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect]zaza= x^2- 13x  :[font = input; preserveAspect]zaza /. x-> so :[font = input; preserveAspect] Position[{a,s,a,a,a,1,4},a] :[font = text; inactive; preserveAspect; endGroup]There's lots more:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]ShortCuts!!!  :[font = text; inactive; preserveAspect]Some of this is subtle: ALL of it is useful!   Use lots of parantheses to guarantee the  proper order of operations.:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Apply[f,  expr ]   ===   f[expr]     ===    expr // f         ===    f  @@ {expr}:[font = input; preserveAspect]Clear[f,expr] :[font = input; preserveAspect]f[expr] ===   (f @@ {expr}) :[font = input; preserveAspect]f[expr] ===   (expr // f) :[font = input; preserveAspect]Sqrt @@ {4}  4 // Sqrt Sin[37Pi/31] //N :[font = text; inactive; preserveAspect]This   trick  is  useful for  getting rid of extra curly braces::[font = input; preserveAspect]Join @@  {{expr}} :[font = input; preserveAspect; endGroup]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Map[f.expr]  ===    f /@ expr      :[font = text; inactive; preserveAspect]This is very useful!:[font = input; preserveAspect]f /@ {a,b,c} :[font = input; preserveAspect](Sqrt /@ {38,82,21})  //N :[font = input; preserveAspect; endGroup]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Function    # &:[font = input; preserveAspect]:[font = text; inactive; preserveAspect]This one comes up a lot.    #   is a dummy variable    in a pure function &:[font = input; preserveAspect]Sqrt[1+ # ] &    /@   {3,8,15} :[font = input; preserveAspect]Prime[#^2]+# &  /@ Table[2k-1, {k,1,3}] :[font = input; preserveAspect]3#-5#^2 & @@ {x} :[font = input; preserveAspect; endGroup; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Graphics:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Plotting Functions:[font = input; preserveAspect]Plot[Cos[Sin[x]],{x,-Pi,Pi}] :[font = input; preserveAspect]Table[Sin[k*x], {k,1,3}] :[font = input; preserveAspect]{Sin[x], Sin[2*x], Sin[3*x]} :[font = input; preserveAspect]Plot[{Sin[x], Sin[2*x], Sin[3*x]}, {x,0,2Pi}] :[font = input; preserveAspect]Plot[Evaluate[Table[Sin[k*x], {k,1,5}]], {x,0,2Pi}] :[font = input; preserveAspect]Table[Plot[Sin[k*x], {x,0,2Pi}],{k,1,10}] :[font = text; inactive; preserveAspect]This last one makes a good movie.  After its done drawing, double click on one of the graphics cells to animate.   Note the control buttonsthat appear in the lower right of the  window.:[font = input; preserveAspect]:[font = input; preserveAspect]Plot3D[Sin[x*y]Exp[-x^2-y^2],{x,-3,3},{y,-2,2}] :[font = input; preserveAspect]Plot3D[Sin[x*y]Exp[-x^2-y^2],{x,-3,3},{y,-2,2},	PlotPoints->{40,6},	ViewPoint->{6,5,6}, 	Boxed->False]	:[font = input; preserveAspect] ParametricPlot[{Sin[t],Cos[.5t]},{t,0,4Pi}]  :[font = input; preserveAspect]ParametricPlot3D[{Sin[t],Cos[.5t],Cos[t]Sin[.5t]}, 				{t,0,4Pi}] 				:[font = input; preserveAspect]ParametricPlot3D[{.3Cos[u](3+Cos[v]),					.3Sin[u](3+Cos[v]),					 .3 Sin[v]},			{u,0,Pi},{v,0,2Pi}] 			:[font = input; preserveAspect]Table[ParametricPlot3D[{-.3Cos[u](3+Sin[v]), 					-.3Sin[u](3+Sin[v]),					 -.3 Cos[v]},			{u,-Pi k/10,Pi k/10},{v,-Pi k/10,Pi k/10},			Boxed->False, Axes->False,			AspectRatio->1/1,			SphericalRegion->True], {k,1,10}]			:[font = text; inactive; preserveAspect]See also  ContourPlot, DensityPlot;[s]2:0,0;10,1;34,-1;2:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;:[font = text; inactive; preserveAspect; endGroup]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Graphics Primatives:[font = text; inactive; preserveAspect]These are basic units  in the graphics environment.  These include Polygons Lines, etc. but also commands like Hue and GrayLevel that affect the primatives that follow them.:[font = input; preserveAspect]a=Polygon[{{2,3},{3,4},{1,3}}];Show[Graphics[a]]:[font = input; preserveAspect]RPoly:=Polygon[		Table[{Random[],Random[],Random[]},{s,1,3}]] (*note  :=  to keep from evaluating the Randomnumbers until we want them *) :[font = input; preserveAspect]:[font = input; preserveAspect]Stuff=Join @@ Table [{GrayLevel[Random[]], RPoly},	{k,1,5}] 	Show[Graphics3D[ Stuff,Lighting->False	  ] ]:[font = input; preserveAspect]:[font = input; preserveAspect]Cubes=Table[Cuboid[{k,k,k}],{k,0,2,.4}] Show[Graphics3D[Cubes]]:[font = input; preserveAspect]:[font = text; inactive; preserveAspect]See also  Line,  Point,  Rectangle, Circle  Disk.  There   are a great number of options as well.   Try Command-V   for the ViewPoint Selector.    Basic format is Show[Graphics[{primitive, primitive,...}, option, option, option,...]];[s]5:0,0;10,1;14,2;16,3;49,4;234,-1;5:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect]<<Graphics/Polyhedra.m   (*this loads a package 					 with a lot of polyhedra in it*):[font = input; preserveAspect]Show[Graphics3D[Dodecahedron[],Boxed->False]] :[font = input; preserveAspect]Show[Graphics3D[Dodecahedron[]//Stellate//Stellate,		Boxed->False]]:[font = input; preserveAspect; endGroup]:[font = subsubsection; inactive; Cclosed; preserveAspect; startGroup]Getting  GEOMVIEW OUTPUT:[font = text; inactive; preserveAspect]There are two main ways to put   Mathematica  pictures into GeomViewFirst,   one can simply write an OOGL file and then load this into GeomView:;[s]3:0,0;33,1;44,2;146,-1;3:1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect]<<OOGL.m :[font = input; preserveAspect]a=2;x=(a+Cos[u/2]Sin[t]-Sin[u/2]Sin[2t])Cos[u]; y=(a+Cos[u/2]Sin[t]-Sin[u/2]Sin[2t])Sin[u];z=Sin[u/2]Sin[t]+Cos[u/2]Sin[2t];:[font = text; inactive; preserveAspect]The  command to use is  WriteOOGL["file", GraphicsObject]GraphicsObject  could be Graphics3D[ etc ]  ,  ParametricPlot3D [ etc ]or Plot3D[ etc  ]:[font = input; preserveAspect]WriteOOGL["foo.oogl",ParametricPlot3D[   	{x,y,z},	{t,0,2Pi},{u,0,2Pi}]]:[font = input; preserveAspect]  :[font = text; inactive; preserveAspect]If you are actually at an Iris, you can load a  picture right into geomview!The ideal set up is to sit at a NeXT next to an Iris.:[font = input; preserveAspect] :[font = input; preserveAspect]<<Geomview.m :[font = text; inactive; preserveAspect]Log into the Iris    and in Mathematica type in  something like:;[s]3:0,0;28,1;39,2;66,-1;3:1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = text; inactive; preserveAspect]SetOptions[Geomview, DisplayHost -> "strauss@voronoi" ](I'm strauss,  and I have GeomView loaded on voronoi);[s]2:0,0;56,1;110,-1;2:1,10,8,Courier,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = text; inactive; preserveAspect]This should appear in Geomview::[font = input; preserveAspect; endGroup; endGroup]ParametricPlot3D[{.3Cos[u](3+Cos[v]),					.3Sin[u](3+Cos[v]), 					 .3 Sin[v]},			{u,0,Pi},{v,0,2Pi}] :[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Loading Packages:[font = text; inactive; preserveAspect; endGroup; endGroup]There are a lot of packages !  Use the function browser to explore!You can load these by<< directory/package.m;[s]2:0,0;92,1;114,-1;2:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;:[font = section; inactive; preserveAspect; startGroup]Samples:[font = text; inactive; preserveAspect]Here are some sample programs.  It might be  a good idea to  Quit the Kernel and start againbefore running these. These aren't particularly representative of all the things that you can do; they're just the sort of things I have around.    (Also, these are shorter than most ):[font = subsection; inactive; Cclosed; preserveAspect; startGroup]A One Liner:[font = text; inactive; preserveAspect]Shamelessly lifted from the Winter 1991 issue of Mathematica Journal;[s]3:0,0;49,1;60,2;68,-1;3:1,11,8,Times,0,12,0,0,0;1,10,8,Times,2,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = text; inactive; preserveAspect]Gives the i & js    such that i^2+j^2  is the square of an integer::[font = input; preserveAspect]ListDensityPlot[ 	Table[If[IntegerQ[		Sqrt[i^2+j^2]],0,1],{i,50},{j,50}]]:[font = text; inactive; preserveAspect]:[font = input; preserveAspect; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]Fibonaccis:[font = input; preserveAspect]fib[0] = 1; fib[1] = 1;fib[n_]:= fib [n] = fib[n-1]+fib[n-2]:[font = input; preserveAspect; endGroup]fib[120]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]An   Actual Ugly Calculation  made easy with Mathematica ;[s]3:0,0;45,1;56,2;58,-1;3:1,12,9,Times,1,14,0,0,0;1,13,10,Times,3,14,0,0,0;1,12,9,Times,1,14,0,0,0;:[font = text; inactive; preserveAspect]This really came up!    A parametric equation  for the sphere is  given as f[u,v below. ParametricPlot3D shows this is really right.The surface area for a patch of a  surface given parametrically isIntegral over the patch of ||( partial f  w.r.t. u ) crossproduct (partial of f w.r.t. v) || du dvWhat   does this work out to be for the sphere?	Clear[a,b,c,d,e,f,g,u,v];[s]2:0,0;352,1;377,-1;2:1,11,8,Times,0,12,0,0,0;1,10,8,Courier,1,12,0,0,0;:[font = input; preserveAspect]f=  { Cos[u] Cos[v],Sin[u] Cos[v],Sin[v]};  :[font = input; preserveAspect] ParametricPlot3D[f, {v,-Pi/2, Pi/2},{u,0,2Pi}] :[font = text; inactive; preserveAspect]Norm just takes the norm of a vector.  Crossproduct does just that.  There is also a package LinearAlgebra/CrossProduct.m   that has this function.:[font = input; preserveAspect]Norm[vector_List]:= Sqrt[vector.vector ] (* for example*)  Norm[{a,b,c}]  :[font = input; preserveAspect]CrossProduct[vector1_List,vector2_List]:=Table[(-1)^(k-1) 			Det[{Drop[vector1,{k}],				Drop[vector2,{k}]}]  ,{k,1,3}](* for example*) CrossProduct[{a,b,c},{d,e,g}] :[font = input; preserveAspect]integrand= Norm[    	CrossProduct[D[f,u], D[f,v] ]]:[font = text; inactive; preserveAspect]YECH!  Well, the whole point  of this is that the answer is much nicer!:[font = input; preserveAspect]Simplify[integrand]  :[font = text; inactive; preserveAspect]I don't know why it wouldn't take the last obvious step, but we know what to do.   Here's the integrand in action    (The Evaluate[vv]   is a kludge ):;[s]3:0,0;122,1;135,2;151,-1;3:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;:[font = input; preserveAspect]AreaOfPatchOnSphere[uRange_,vRange_]:= 	(vv=Prepend[vRange,v]; uu=Prepend[uRange,u]; 	 	NIntegrate[  		NIntegrate[Abs[Cos[v]] , Evaluate[vv] ], 			Evaluate[uu ]]) 		:[font = input; preserveAspect]ShowPatchOnSphere[uRange_,vRange_]:= 	(vv=Prepend[vRange,v]; uu=Prepend[uRange,u]; 		ParametricPlot3D[f,Evaluate[uu ],Evaluate[vv]]):[font = input; preserveAspect]  :[font = input; preserveAspect]AreaOfPatchOnSphere[{0,3Pi/4},{0,Pi/4}] ShowPatchOnSphere[{0,3Pi/4},{0,Pi/4}]:[font = input; preserveAspect; endGroup]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]The Harmonograph:[font = text; inactive; preserveAspect]As  seen at  the  Minnesota Science Museum:[font = input; preserveAspect] damp[t_]:= 5 - .005 t:[font = input; preserveAspect]shift= .2 Pi ; :[font = text; inactive; preserveAspect]Good phases include:   201/203    101/203:[font = input; preserveAspect]phase= 100.5 / 203 ; :[font = input; preserveAspect] curve= damp[t]* {Sin[t], Sin[phase*t+shift]} ;:[font = input; preserveAspect; endGroup] ParametricPlot[{Evaluate[curve]},{t,-20,900},		Axes->False,PlotPoints->1000, AspectRatio->3/2]:[font = subsection; inactive; Cclosed; preserveAspect; startGroup]The basic Spirograph Set::[font = text; inactive; preserveAspect]Given two wheels, big one with p teeth, little with q teeth. Little wheel has radius 1 and is inside big wheel. Hole for pen is distance t from center of little wheel.theta should run from 0 to 2Pi*q/GCD[p,q],and the numebr of spikes will be p/GCD[p,q]:[font = input; preserveAspect]Spirograph[p_Integer,q_Integer,t_]:={				(p/q-1)Cos[theta]+t Cos[(1-p/q)theta],				(p/q-1)Sin[theta]+t Sin[(1-p/q)theta]	} :[font = input; preserveAspect]tmax[p_Integer,q_Integer]:=2Pi*q/GCD[p,q] pmax[p_Integer,q_Integer,n_Integer]:=p/GCD[p,q]*n:[font = input; preserveAspect; endGroup]P=72;   (*change P and Q  *)Q=25;M=30;ParametricPlot[Evaluate[	Spirograph[P,Q,.7]],	{theta,0,tmax[P,Q]},	AspectRatio->Automatic,	Axes->False,PlotPoints->pmax[P,Q,M]] :[font = subsection; inactive; preserveAspect; startGroup]Polyhedral groups:[font = text; inactive; preserveAspect]This   is  part of a useful setup for making polyhedra in 3 space.   :[font = subsubsection; inactive; preserveAspect; startGroup]Gunk:[font = input; preserveAspect]g=N /@ (Sqrt[5] +1)/2;  t=1/g;:[font = text; inactive; preserveAspect]These    are generators   for all the platonic symmetries:[font = input; preserveAspect; startGroup]Invert[dodont_Integer (*Mod 2*)][vect_List]:= 		vect*{{1,1,1},{-1,-1,-1}}[[dodont]] RAlong[axis_Integer(*x-1,z-3*)][dodont_Integer (*Mod 2*)][vect_List]:=		vect*{{1,1,1},RotateRight[{-1,1,1},axis-1]}[[dodont]]R5=Table[MatrixPower[.5{{1,-g,t},{g,t,-1},{t,1,g}},k],{k,0,4}];Rot5[pinth_Integer (*Mod 5*)(*about   (1,0,g)*)][vect_List]:=		Dot[R5[[pinth]],vect]Rot3[pinth_Integer (*Mod 3*)(*cwise about   (1,1,1)*)][vect_List]:=		RotateRight[vect,pinth-1]				Ident[vect_]:=vect(* given a  face and a generator  mmap of order order, 	fimages givesa list of all the images of the face *)fimages[mmap_,order_,face_]:=    Chop[#,10^-13]& @ 	Table[		mmap[k][face[[j]]],			{k,1,order},{j,1,Length[face]}] ;[s]27:0,0;22,1;31,2;106,3;117,4;134,5;143,6;300,7;328,8;387,9;421,10;489,11;501,12;505,13;523,14;527,15;537,16;542,17;546,18;553,19;599,20;660,21;663,22;682,23;686,24;717,25;718,26;719,-1;27:1,10,8,Courier,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,10,8,Courier,1,12,0,0,0;1,10,8,Courier,1,12,0,0,0;:[font = message; inactive; preserveAspect]General::spell1:    Possible spelling error: new symbol name "Invert"     is similar to existing symbol "Insert".:[font = message; inactive; preserveAspect; endGroup]General::spell1:    Possible spelling error: new symbol name "Ident"     is similar to existing symbol "Indent".:[font = text; inactive; preserveAspect]These work like this::[font = input; preserveAspect; startGroup]Rot3[2][{x,y,z}] :[font = output; output; inactive; preserveAspect; endGroup]{z, x, y};[o]{z, x, y}:[font = input; preserveAspect; startGroup]RAlong[1][2][{x,y,z}]:[font = output; output; inactive; preserveAspect; endGroup]{-x, y, z};[o]{-x, y, z}:[font = input; preserveAspect; startGroup]fimages[Rot5,5,{{x,y,z},{a,b,c}}] :[font = output; output; inactive; preserveAspect; endGroup; endGroup]{{{x, y, z}, {a, b, c}}, {{0.5*x - 0.809016994374947*y +       0.3090169943749474*z, 0.809016994374947*x + 0.3090169943749474*y -       0.5*z, 0.3090169943749474*x + 0.5*y + 0.809016994374947*z},     {0.5*a - 0.809016994374947*b + 0.3090169943749474*c,      0.809016994374947*a + 0.3090169943749474*b - 0.5*c,      0.3090169943749474*a + 0.5*b + 0.809016994374947*c}},    {{-0.3090169943749474*x - 0.5*y + 0.809016994374947*z,      0.5*x - 0.809016994374947*y - 0.3090169943749474*z,      0.809016994374947*x + 0.3090169943749474*y + 0.5*z},     {-0.3090169943749474*a - 0.5*b + 0.809016994374947*c,      0.5*a - 0.809016994374947*b - 0.3090169943749474*c,      0.809016994374947*a + 0.3090169943749474*b + 0.5*c}},    {{-0.3090169943749474*x + 0.5000000000000001*y + 0.809016994374947*z,      -0.5*x - 0.809016994374947*y + 0.3090169943749474*z,      0.809016994374947*x - 0.3090169943749474*y + 0.5*z},     {-0.3090169943749474*a + 0.5000000000000001*b + 0.809016994374947*c,      -0.5*a - 0.809016994374947*b + 0.3090169943749474*c,      0.809016994374947*a - 0.3090169943749474*b + 0.5*c}},    {{0.5*x + 0.809016994374947*y + 0.3090169943749474*z,      -0.809016994374947*x + 0.3090169943749474*y + 0.5*z,      0.3090169943749474*x - 0.5*y + 0.809016994374947*z},     {0.5*a + 0.809016994374947*b + 0.3090169943749474*c,      -0.809016994374947*a + 0.3090169943749474*b + 0.5*c,      0.3090169943749474*a - 0.5*b + 0.809016994374947*c}}};[o]{{{x, y, z}, {a, b, c}}, {{0.5 x - 0.809017 y + 0.309017 z,      0.809017 x + 0.309017 y - 0.5 z, 0.309017 x + 0.5 y + 0.809017 z},     {0.5 a - 0.809017 b + 0.309017 c, 0.809017 a + 0.309017 b - 0.5 c,      0.309017 a + 0.5 b + 0.809017 c}},    {{-0.309017 x - 0.5 y + 0.809017 z, 0.5 x - 0.809017 y - 0.309017 z,      0.809017 x + 0.309017 y + 0.5 z},     {-0.309017 a - 0.5 b + 0.809017 c, 0.5 a - 0.809017 b - 0.309017 c,      0.809017 a + 0.309017 b + 0.5 c}},    {{-0.309017 x + 0.5 y + 0.809017 z, -0.5 x - 0.809017 y + 0.309017 z,      0.809017 x - 0.309017 y + 0.5 z},     {-0.309017 a + 0.5 b + 0.809017 c, -0.5 a - 0.809017 b + 0.309017 c,      0.809017 a - 0.309017 b + 0.5 c}},    {{0.5 x + 0.809017 y + 0.309017 z, -0.809017 x + 0.309017 y + 0.5 z,      0.309017 x - 0.5 y + 0.809017 z},     {0.5 a + 0.809017 b + 0.309017 c, -0.809017 a + 0.309017 b + 0.5 c,      0.309017 a - 0.5 b + 0.809017 c}}}:[font = subsubsection; inactive; preserveAspect; startGroup]For example, the Truncated Octahedron::[font = input; preserveAspect]:[font = text; inactive; preserveAspect]First, the truncated octahedron:[font = input; preserveAspect]HexFace = Join @@ 	(fimages[Rot3,3,{{2,1,0},{1,2,0}}]);HexFaces=  Join @@	(fimages[RAlong[1],2, #]& /@ 		(Join @@ ( fimages[RAlong[3],2,#]& /@		fimages[RAlong[2],2,HexFace] ) ));SqFace =  { {2,1,0},	 {2,0,1}, {2,-1,0},{2,0,-1} };SqFaces=  Join @@ 		(fimages[Rot3,3, #]& /@ ( 		fimages[RAlong[1],2,SqFace] ));TrOcta=  Join [ 	{GrayLevel[.9]},				 	Polygon /@ SqFaces, 				 	{GrayLevel[.10]},					Polygon /@HexFaces];:[font = text; inactive; preserveAspect]This Can be checked by:[font = input; preserveAspect]Show[Graphics3D[TrOcta] ,Lighting->False,Boxed->False] :[font = input; preserveAspect; endGroup]:[font = subsubsection; inactive; preserveAspect; startGroup]Another::[font = input; preserveAspect] :[font = input; preserveAspect]Dodecafaces=      (dface={ 	{1,0,1-t},{t,t,t},{0,1-t,1},			{0,t-1,1},{t,-t,t} };Join@@ (fimages[Rot3,3,#]& /@ (Join@@ (fimages[RAlong[3],2,#]& /@fimages[RAlong[1],2,dface] )))):[font = input; preserveAspect]Dodeca = Polygon /@ Dodecafaces;  :[font = input; preserveAspect; endGroup; endGroup; endGroup]Show[Graphics3D[Dodeca] ,Boxed->False]  :[font = section; inactive; Cclosed; preserveAspect; startGroup]More:[font = text; inactive; preserveAspect; endGroup; endGroup]These are meant just to be a taste.   For more,  see /u/lib/mathematica/Notebooksu/strauss/Mathematica     (although these are  not  gaurenteed to be in good shape)/u/lib/mathematica/Notebooks/Steiner.m     is pretty coolThere are many good books out in the Big Room.  Stan Wagon's Mathematica in Action is particularly good.;[s]11:0,0;53,1;81,2;82,3;92,4;103,5;167,6;205,7;287,8;298,9;308,10;331,-1;11:1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,10,8,Times,3,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;1,10,8,Times,3,12,0,0,0;1,10,8,Times,1,12,0,0,0;1,11,8,Times,0,12,0,0,0;^*)